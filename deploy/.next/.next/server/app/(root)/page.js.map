{"version":3,"file":"../app/(root)/page.js","mappings":"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","sources":["webpack://jsm_banking/external commonjs \"next/dist/client/components/action-async-storage.external.js\"","webpack://jsm_banking/external commonjs \"next/dist/client/components/request-async-storage.external.js\"","webpack://jsm_banking/external commonjs \"next/dist/client/components/static-generation-async-storage.external.js\"","webpack://jsm_banking/external commonjs \"next/dist/compiled/next-server/app-page.runtime.prod.js\"","webpack://jsm_banking/external commonjs \"node-appwrite\"","webpack://jsm_banking/external commonjs2 \"assert\"","webpack://jsm_banking/external commonjs2 \"async_hooks\"","webpack://jsm_banking/external commonjs2 \"child_process\"","webpack://jsm_banking/external commonjs2 \"crypto\"","webpack://jsm_banking/external commonjs2 \"diagnostics_channel\"","webpack://jsm_banking/external commonjs2 \"domain\"","webpack://jsm_banking/external commonjs2 \"events\"","webpack://jsm_banking/external commonjs2 \"fs\"","webpack://jsm_banking/external commonjs2 \"http\"","webpack://jsm_banking/external commonjs2 \"https\"","webpack://jsm_banking/external commonjs2 \"inspector\"","webpack://jsm_banking/external commonjs2 \"net\"","webpack://jsm_banking/external commonjs2 \"os\"","webpack://jsm_banking/external commonjs2 \"path\"","webpack://jsm_banking/external commonjs2 \"punycode\"","webpack://jsm_banking/external commonjs2 \"stream\"","webpack://jsm_banking/external commonjs2 \"tls\"","webpack://jsm_banking/external commonjs2 \"tty\"","webpack://jsm_banking/external commonjs2 \"url\"","webpack://jsm_banking/external commonjs2 \"util\"","webpack://jsm_banking/external commonjs2 \"zlib\"","webpack://jsm_banking/./components/RecentTransactions.tsx","webpack://jsm_banking/./components/Category.tsx","webpack://jsm_banking/./components/RightSidebar.tsx","webpack://jsm_banking/./components/TotalBalanceBox.tsx","webpack://jsm_banking/app/(root)/page.tsx","webpack://jsm_banking/sentry-wrapper-module","webpack://jsm_banking/?81f5","webpack://jsm_banking/?43a5","webpack://jsm_banking/./components/AnimatedCounter.tsx","webpack://jsm_banking/./components/BankInfo.tsx","webpack://jsm_banking/./components/BankTabItem.tsx","webpack://jsm_banking/./components/Copy.tsx","webpack://jsm_banking/./node_modules/@kurkle/color/dist/color.esm.js","webpack://jsm_banking/./node_modules/chart.js/dist/chunks/helpers.dataset.js","webpack://jsm_banking/./node_modules/chart.js/dist/chart.js","webpack://jsm_banking/./node_modules/react-chartjs-2/dist/index.js","webpack://jsm_banking/./components/DoughnutChart.tsx","webpack://jsm_banking/./components/Pagination.tsx","webpack://jsm_banking/../src/progress.tsx","webpack://jsm_banking/./components/ui/progress.tsx","webpack://jsm_banking/../src/roving-focus-group.tsx","webpack://jsm_banking/../src/tabs.tsx","webpack://jsm_banking/./components/ui/tabs.tsx","webpack://jsm_banking/./node_modules/countup.js/dist/countUp.umd.js","webpack://jsm_banking/./node_modules/react-countup/build/index.js","webpack://jsm_banking/./components/BankCard.tsx","webpack://jsm_banking/../../src/defaultAttributes.ts","webpack://jsm_banking/../../../../shared/src/utils.ts","webpack://jsm_banking/../../src/createLucideIcon.ts","webpack://jsm_banking/../../../src/icons/arrow-up-right.ts","webpack://jsm_banking/./components/LegalBanner.tsx","webpack://jsm_banking/./node_modules/next/dist/api/link.js"],"sourcesContent":["module.exports = require(\"next/dist/client/components/action-async-storage.external.js\");","module.exports = require(\"next/dist/client/components/request-async-storage.external.js\");","module.exports = require(\"next/dist/client/components/static-generation-async-storage.external.js\");","module.exports = require(\"next/dist/compiled/next-server/app-page.runtime.prod.js\");","module.exports = require(\"node-appwrite\");","module.exports = require(\"assert\");","module.exports = require(\"async_hooks\");","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"domain\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"inspector\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"punycode\");","module.exports = require(\"stream\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","import Link from 'next/link'\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\"\nimport { BankTabItem } from './BankTabItem'\nimport BankInfo from './BankInfo'\nimport TransactionsTable from './TransactionsTable'\nimport { Pagination } from './Pagination'\nimport { ManualTransactionSheet } from './ManualTransactionSheet'\n\nconst RecentTransactions = ({\n  accounts,\n  transactions = [],\n  appwriteItemId,\n  page = 1,\n}: RecentTransactionsProps) => {\n  const rowsPerPage = 10;\n  const totalPages = Math.ceil(transactions.length / rowsPerPage);\n\n  const indexOfLastTransaction = page * rowsPerPage;\n  const indexOfFirstTransaction = indexOfLastTransaction - rowsPerPage;\n\n  const currentTransactions = transactions.slice(\n    indexOfFirstTransaction, indexOfLastTransaction\n  )\n\n  return (\n    <section className=\"recent-transactions\">\n      <header className=\"flex flex-wrap items-center justify-between gap-3\">\n        <h2 className=\"recent-transactions-label\">Recent transactions</h2>\n        <div className=\"flex items-center gap-2\">\n          <ManualTransactionSheet\n            accounts={accounts}\n            defaultBankId={appwriteItemId}\n          />\n          <Link\n            href={`/transaction-history/?id=${appwriteItemId}`}\n            className=\"view-all-btn\"\n          >\n            View all\n          </Link>\n        </div>\n      </header>\n\n      <Tabs defaultValue={appwriteItemId} className=\"w-full\">\n      <TabsList className=\"recent-transactions-tablist\">\n          {accounts.map((account: Account) => (\n            <TabsTrigger key={account.id} value={account.appwriteItemId}>\n              <BankTabItem\n                key={account.id}\n                account={account}\n                appwriteItemId={appwriteItemId}\n              />\n            </TabsTrigger>\n          ))}\n        </TabsList>\n\n        {accounts.map((account: Account) => (\n          <TabsContent\n            value={account.appwriteItemId}\n            key={account.id}\n            className=\"space-y-4\"\n          >\n            <BankInfo \n              account={account}\n              appwriteItemId={appwriteItemId}\n              type=\"full\"\n            />\n\n            <TransactionsTable transactions={currentTransactions} />\n            \n\n            {totalPages > 1 && (\n              <div className=\"my-4 w-full\">\n                <Pagination totalPages={totalPages} page={page} />\n              </div>\n            )}\n          </TabsContent>\n        ))}\n      </Tabs>\n    </section>\n  )\n}\n\nexport default RecentTransactions\n","import Image from \"next/image\";\n\nimport { topCategoryStyles } from \"@/constants\";\nimport { cn } from \"@/lib/utils\";\n\nimport { Progress } from \"./ui/progress\";\n\nconst Category = ({ category }: CategoryProps) => {\n  const {\n    bg,\n    circleBg,\n    text: { main, count },\n    progress: { bg: progressBg, indicator },\n    icon,\n  } = topCategoryStyles[category.name as keyof typeof topCategoryStyles] ||\n  topCategoryStyles.default;\n\n  return (\n    <div className={cn(\"gap-[18px] flex p-4 rounded-xl\", bg)}>\n      <figure className={cn(\"flex-center size-10 rounded-full\", circleBg)}>\n        <Image src={icon} width={20} height={20} alt={category.name} />\n      </figure>\n      <div className=\"flex w-full flex-1 flex-col gap-2\">\n        <div className=\"text-14 flex justify-between\">\n          <h2 className={cn(\"font-medium\", main)}>{category.name}</h2>\n          <h3 className={cn(\"font-normal\", count)}>{category.count}</h3>\n        </div>\n        <Progress\n          value={(category.count / category.totalCount) * 100}\n          className={cn(\"h-2 w-full\", progressBg)}\n          indicatorClassName={cn(\"h-2 w-full\", indicator)}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Category;","import Image from 'next/image'\nimport Link from 'next/link'\nimport React from 'react'\nimport BankCard from './BankCard'\nimport { countTransactionCategories } from '@/lib/utils'\nimport Category from './Category'\n\nconst RightSidebar = ({ user, transactions, banks }: RightSidebarProps) => {\n  const categories: CategoryCount[] = countTransactionCategories(transactions);\n\n  return (\n    <aside className=\"right-sidebar\">\n      <section className=\"flex flex-col pb-8\">\n        <div className=\"profile-banner\" />\n        <div className=\"profile\">\n          <div className=\"profile-img\">\n            <span className=\"text-5xl font-bold text-blue-500\">{user.firstName[0]}</span>\n          </div>\n\n          <div className=\"profile-details\">\n            <h1 className='profile-name'>\n              {user.firstName} {user.lastName}\n            </h1>\n            <p className=\"profile-email\">\n              {user.email}\n            </p>\n          </div>\n        </div>\n      </section>\n\n      <section className=\"banks\">\n        <div className=\"flex w-full justify-between\">\n          <h2 className=\"header-2\">My Banks</h2>\n          <Link href=\"/\" className=\"flex gap-2\">\n            <Image \n               src=\"/icons/plus.svg\"\n              width={20}\n              height={20}\n              alt=\"plus\"\n            />\n            <h2 className=\"text-14 font-semibold text-gray-600\">\n              Add Bank\n            </h2>\n          </Link>\n        </div>\n\n        {banks?.length > 0 && (\n          <div className=\"relative flex flex-1 flex-col items-center justify-center gap-5\">\n            <div className='relative z-10'>\n              <BankCard \n                key={banks[0].$id}\n                account={banks[0]}\n                userName={`${user.firstName} ${user.lastName}`}\n                showBalance={false}\n              />\n            </div>\n            {banks[1] && (\n              <div className=\"absolute right-0 top-8 z-0 w-[90%]\">\n                <BankCard \n                  key={banks[1].$id}\n                  account={banks[1]}\n                  userName={`${user.firstName} ${user.lastName}`}\n                  showBalance={false}\n                />\n              </div>\n            )}\n          </div>\n        )}\n\n        <div className=\"mt-10 flex flex-1 flex-col gap-6\">\n          <h2 className=\"header-2\">Top categories</h2>\n\n          <div className='space-y-5'>\n            {categories.map((category, index) => (\n              <Category key={category.name} category={category} />\n            ))}\n          </div>\n        </div>\n      </section>\n    </aside>\n  )\n}\n\nexport default RightSidebar","import AnimatedCounter from './AnimatedCounter';\nimport DoughnutChart from './DoughnutChart';\n\nconst TotalBalanceBox = ({\n  accounts = [], totalBanks, totalCurrentBalance\n}: TotalBalanceBoxProps) => {\n  return (\n    <section className=\"total-balance\">\n      <div className=\"total-balance-chart\">\n        <DoughnutChart accounts={accounts} />\n      </div>\n\n      <div className=\"flex flex-col gap-6\">\n        <h2 className=\"header-2\">\n          Bank Accounts: {totalBanks}\n        </h2>\n        <div className=\"flex flex-col gap-2\">\n          <p className=\"total-balance-label\">\n            Total Current Balance\n          </p>\n\n          <div className=\"total-balance-amount flex-center gap-2\">\n            <AnimatedCounter amount={totalCurrentBalance} />\n          </div>\n        </div>\n      </div>\n    </section>\n  )\n}\n\nexport default TotalBalanceBox","import HeaderBox from '@/components/HeaderBox'\nimport LegalBanner from '@/components/LegalBanner';\nimport RecentTransactions from '@/components/RecentTransactions';\nimport RightSidebar from '@/components/RightSidebar';\nimport TotalBalanceBox from '@/components/TotalBalanceBox';\nimport { getAccount, getAccounts } from '@/lib/actions/bank.actions';\nimport { getLoggedInUser } from '@/lib/actions/user.actions';\n\nconst Home = async ({ searchParams: { id, page } }: SearchParamProps) => {\n  const currentPage = Number(page as string) || 1;\n  const loggedIn = await getLoggedInUser();\n  const accounts = await getAccounts({ \n    userId: loggedIn.$id \n  })\n\n  if(!accounts) return;\n  \n  const accountsData = accounts?.data;\n  const appwriteItemId = (id as string) || accountsData[0]?.appwriteItemId;\n\n  const account = await getAccount({ appwriteItemId })\n\n  return (\n    <section className=\"home\">\n      <div className=\"home-content\">\n        <header className=\"home-header\">\n          <HeaderBox \n            type=\"greeting\"\n            title=\"Welcome\"\n            user={loggedIn?.firstName || 'Guest'}\n            subtext=\"Access and manage your account and transactions efficiently.\"\n          />\n\n          <LegalBanner />\n\n          <TotalBalanceBox \n            accounts={accountsData}\n            totalBanks={accounts?.totalBanks}\n            totalCurrentBalance={accounts?.totalCurrentBalance}\n          />\n        </header>\n\n        <RecentTransactions \n          accounts={accountsData}\n          transactions={account?.transactions}\n          appwriteItemId={appwriteItemId}\n          page={currentPage}\n        />\n      </div>\n\n      <RightSidebar \n        user={loggedIn}\n        transactions={account?.transactions}\n        banks={accountsData?.slice(0, 2)}\n      />\n    </section>\n  )\n}\n\nexport default Home\n","import { _nullishCoalesce, _optionalChain } from '@sentry/utils';\nimport * as Sentry from '@sentry/nextjs';\nimport { requestAsyncStorage } from 'next/dist/client/components/request-async-storage.external.js';\nimport * as serverComponentModule from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\nexport * from '__SENTRY_WRAPPING_TARGET_FILE__.cjs';\n\nconst serverComponent = serverComponentModule.default;\n\nlet wrappedServerComponent;\nif (typeof serverComponent === 'function') {\n  // For some odd Next.js magic reason, `headers()` will not work if used inside `wrapServerComponentsWithSentry`.\n  // Current assumption is that Next.js applies some loader magic to userfiles, but not files in node_modules. This file\n  // is technically a userfile so it gets the loader magic applied.\n  wrappedServerComponent = new Proxy(serverComponent, {\n    apply: (originalFunction, thisArg, args) => {\n      let sentryTraceHeader = undefined;\n      let baggageHeader = undefined;\n      let headers = undefined;\n\n      // We try-catch here just in `requestAsyncStorage` is undefined since it may not be defined\n      try {\n        const requestAsyncStore = requestAsyncStorage.getStore();\n        sentryTraceHeader = _nullishCoalesce(_optionalChain([requestAsyncStore, 'optionalAccess', _ => _.headers, 'access', _2 => _2.get, 'call', _3 => _3('sentry-trace')]), () => ( undefined));\n        baggageHeader = _nullishCoalesce(_optionalChain([requestAsyncStore, 'optionalAccess', _4 => _4.headers, 'access', _5 => _5.get, 'call', _6 => _6('baggage')]), () => ( undefined));\n        headers = _optionalChain([requestAsyncStore, 'optionalAccess', _7 => _7.headers]);\n      } catch (e) {\n        /** empty */\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n      return Sentry.wrapServerComponentWithSentry(originalFunction , {\n        componentRoute: '/(root)',\n        componentType: 'Page',\n        sentryTraceHeader,\n        baggageHeader,\n        headers,\n      }).apply(thisArg, args);\n    },\n  });\n} else {\n  wrappedServerComponent = serverComponent;\n}\n\nconst generateMetadata = serverComponentModule.generateMetadata\n  ? Sentry.wrapGenerationFunctionWithSentry(serverComponentModule.generateMetadata, {\n      componentRoute: '/(root)',\n      componentType: 'Page',\n      generationFunctionIdentifier: 'generateMetadata',\n      requestAsyncStorage,\n    })\n  : undefined;\n\nconst generateImageMetadata = serverComponentModule.generateImageMetadata\n  ? Sentry.wrapGenerationFunctionWithSentry(serverComponentModule.generateImageMetadata, {\n      componentRoute: '/(root)',\n      componentType: 'Page',\n      generationFunctionIdentifier: 'generateImageMetadata',\n      requestAsyncStorage,\n    })\n  : undefined;\n\nconst generateViewport = serverComponentModule.generateViewport\n  ? Sentry.wrapGenerationFunctionWithSentry(serverComponentModule.generateViewport, {\n      componentRoute: '/(root)',\n      componentType: 'Page',\n      generationFunctionIdentifier: 'generateViewport',\n      requestAsyncStorage,\n    })\n  : undefined;\n\nconst wrappedServerComponent$1 = wrappedServerComponent;\n\nexport { wrappedServerComponent$1 as default, generateImageMetadata, generateMetadata, generateViewport };\n","import \"/Users/kaveh/Horizon-bank/banking/app/(root)/page.tsx\";\nimport \"/Users/kaveh/Horizon-bank/banking/app/(root)/layout.tsx\";\nimport \"next/dist/client/components/not-found-error\";\nimport \"/Users/kaveh/Horizon-bank/banking/app/layout.tsx\";\nimport \"next/dist/client/components/not-found-error\";\"TURBOPACK { transition: next-ssr }\";\nimport { AppPageRouteModule } from \"next/dist/server/future/route-modules/app-page/module.compiled\";\nimport { RouteKind } from \"next/dist/server/future/route-kind\";\n// We inject the tree and pages here so that we can use them in the route\n// module.\nconst tree = {\n        children: [\n        '',\n        {\n        children: [\n        '(root)',\n        {\n        children: ['__PAGE__', {}, {\n          page: [() => import(/* webpackMode: \"eager\" */ \"/Users/kaveh/Horizon-bank/banking/app/(root)/page.tsx\"), \"/Users/kaveh/Horizon-bank/banking/app/(root)/page.tsx\"],\n          \n        }]\n      },\n        {\n        'layout': [() => import(/* webpackMode: \"eager\" */ \"/Users/kaveh/Horizon-bank/banking/app/(root)/layout.tsx\"), \"/Users/kaveh/Horizon-bank/banking/app/(root)/layout.tsx\"],\n'not-found': [() => import(/* webpackMode: \"eager\" */ \"next/dist/client/components/not-found-error\"), \"next/dist/client/components/not-found-error\"],\n        \n      }\n      ]\n      },\n        {\n        'layout': [() => import(/* webpackMode: \"eager\" */ \"/Users/kaveh/Horizon-bank/banking/app/layout.tsx\"), \"/Users/kaveh/Horizon-bank/banking/app/layout.tsx\"],\n'not-found': [() => import(/* webpackMode: \"eager\" */ \"next/dist/client/components/not-found-error\"), \"next/dist/client/components/not-found-error\"],\n        \n      }\n      ]\n      }.children;\nconst pages = [\"/Users/kaveh/Horizon-bank/banking/app/(root)/page.tsx\"];\nexport { tree, pages };\nexport { default as GlobalError } from \"/Users/kaveh/Horizon-bank/banking/app/global-error.jsx\";\nconst __next_app_require__ = __webpack_require__\nconst __next_app_load_chunk__ = () => Promise.resolve()\nexport const originalPathname = \"/(root)/page\";\nexport const __next_app__ = {\n    require: __next_app_require__,\n    loadChunk: __next_app_load_chunk__\n};\nexport * from \"next/dist/server/app-render/entry-base\";\n// Create and export the route module that will be consumed.\nexport const routeModule = new AppPageRouteModule({\n    definition: {\n        kind: RouteKind.APP_PAGE,\n        page: \"/(root)/page\",\n        pathname: \"/\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\",\n        appPaths: []\n    },\n    userland: {\n        loaderTree: tree\n    }\n});\n\n//# sourceMappingURL=app-page.js.map","import(/* webpackMode: \"eager\", webpackExports: [\"default\"] */ \"/Users/kaveh/Horizon-bank/banking/components/AnimatedCounter.tsx\");\n;\nimport(/* webpackMode: \"eager\", webpackExports: [\"default\"] */ \"/Users/kaveh/Horizon-bank/banking/components/BankInfo.tsx\");\n;\nimport(/* webpackMode: \"eager\", webpackExports: [\"BankTabItem\"] */ \"/Users/kaveh/Horizon-bank/banking/components/BankTabItem.tsx\");\n;\nimport(/* webpackMode: \"eager\", webpackExports: [\"default\"] */ \"/Users/kaveh/Horizon-bank/banking/components/Copy.tsx\");\n;\nimport(/* webpackMode: \"eager\", webpackExports: [\"default\"] */ \"/Users/kaveh/Horizon-bank/banking/components/DoughnutChart.tsx\");\n;\nimport(/* webpackMode: \"eager\", webpackExports: [\"ManualTransactionSheet\"] */ \"/Users/kaveh/Horizon-bank/banking/components/ManualTransactionSheet.tsx\");\n;\nimport(/* webpackMode: \"eager\", webpackExports: [\"Pagination\"] */ \"/Users/kaveh/Horizon-bank/banking/components/Pagination.tsx\");\n;\nimport(/* webpackMode: \"eager\", webpackExports: [\"Progress\"] */ \"/Users/kaveh/Horizon-bank/banking/components/ui/progress.tsx\");\n;\nimport(/* webpackMode: \"eager\", webpackExports: [\"Tabs\",\"TabsList\",\"TabsTrigger\",\"TabsContent\"] */ \"/Users/kaveh/Horizon-bank/banking/components/ui/tabs.tsx\");\n;\nimport(/* webpackMode: \"eager\" */ \"/Users/kaveh/Horizon-bank/banking/node_modules/next/dist/client/image-component.js\");\n;\nimport(/* webpackMode: \"eager\" */ \"/Users/kaveh/Horizon-bank/banking/node_modules/next/dist/client/link.js\");\n","'use client';\n\nimport CountUp from 'react-countup';\n\nconst AnimatedCounter = ({ amount }: { amount: number }) => {\n  return (\n    <div className=\"w-full\">\n      <CountUp \n        decimals={2}\n        decimal=\",\"\n        prefix=\"$\"\n        end={amount} \n      />\n    </div>\n  )\n}\n\nexport default AnimatedCounter","\"use client\";\n\nimport Image from \"next/image\";\nimport { useSearchParams, useRouter } from \"next/navigation\";\n\nimport {\n  cn,\n  formUrlQuery,\n  formatAmount,\n  getAccountTypeColors,\n} from \"@/lib/utils\";\n\nconst BankInfo = ({ account, appwriteItemId, type }: BankInfoProps) => {\n  const router = useRouter();\n  const searchParams = useSearchParams();\n\n  const isActive = appwriteItemId === account?.appwriteItemId;\n\n  const handleBankChange = () => {\n    const newUrl = formUrlQuery({\n      params: searchParams.toString(),\n      key: \"id\",\n      value: account?.appwriteItemId,\n    });\n    router.push(newUrl, { scroll: false });\n  };\n\n  const colors = getAccountTypeColors(account?.type as AccountTypes);\n\n  return (\n    <div\n      onClick={handleBankChange}\n      className={cn(`bank-info ${colors.bg}`, {\n        \"shadow-sm border-blue-700\": type === \"card\" && isActive,\n        \"rounded-xl\": type === \"card\",\n        \"hover:shadow-sm cursor-pointer\": type === \"card\",\n      })}\n    >\n      <figure\n        className={`flex-center h-fit rounded-full bg-blue-100 ${colors.lightBg}`}\n      >\n        <Image\n          src=\"/icons/connect-bank.svg\"\n          width={20}\n          height={20}\n          alt={account.subtype}\n          className=\"m-2 min-w-5\"\n        />\n      </figure>\n      <div className=\"flex w-full flex-1 flex-col justify-center gap-1\">\n        <div className=\"bank-info_content\">\n          <h2\n            className={`text-16 line-clamp-1 flex-1 font-bold text-blue-900 ${colors.title}`}\n          >\n            {account.name}\n          </h2>\n          {type === \"full\" && (\n            <p\n              className={`text-12 rounded-full px-3 py-1 font-medium text-blue-700 ${colors.subText} ${colors.lightBg}`}\n            >\n              {account.subtype}\n            </p>\n          )}\n        </div>\n\n        <p className={`text-16 font-medium text-blue-700 ${colors.subText}`}>\n          {formatAmount(account.currentBalance)}\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default BankInfo;\n","\"use client\";\n\nimport { useSearchParams, useRouter } from \"next/navigation\";\n\nimport { cn, formUrlQuery } from \"@/lib/utils\";\n\nexport const BankTabItem = ({ account, appwriteItemId }: BankTabItemProps) => {\n  const searchParams = useSearchParams();\n  const router = useRouter();\n  const isActive = appwriteItemId === account?.appwriteItemId;\n\n  const handleBankChange = () => {\n    const newUrl = formUrlQuery({\n      params: searchParams.toString(),\n      key: \"id\",\n      value: account?.appwriteItemId,\n    });\n    router.push(newUrl, { scroll: false });\n  };\n\n  return (\n    <div\n      onClick={handleBankChange}\n      className={cn(`banktab-item`, {\n        \" border-blue-600\": isActive,\n      })}\n    >\n      <p\n        className={cn(`text-16 line-clamp-1 flex-1 font-medium text-gray-500`, {\n          \" text-blue-600\": isActive,\n        })}\n      >\n        {account.name}\n      </p>\n    </div>\n  );\n};\n","\"use client\";\nimport { useState } from \"react\";\n\nimport { Button } from \"./ui/button\";\n\nconst Copy = ({ title }: { title: string }) => {\n  const [hasCopied, setHasCopied] = useState(false);\n\n  const copyToClipboard = () => {\n    navigator.clipboard.writeText(title);\n    setHasCopied(true);\n\n    setTimeout(() => {\n      setHasCopied(false);\n    }, 2000);\n  };\n\n  return (\n    <Button\n      data-state=\"closed\"\n      className=\"mt-3 flex max-w-[320px] gap-4\"\n      variant=\"secondary\"\n      onClick={copyToClipboard}\n    >\n      <p className=\"line-clamp-1 w-full max-w-full text-xs font-medium text-black-2\">\n        {title} test\n      </p>\n\n      {!hasCopied ? (\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          width=\"24\"\n          height=\"24\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          stroke-width=\"2\"\n          stroke-linecap=\"round\"\n          stroke-linejoin=\"round\"\n          className=\"mr-2 size-4\"\n        >\n          <rect width=\"14\" height=\"14\" x=\"8\" y=\"8\" rx=\"2\" ry=\"2\"></rect>\n          <path d=\"M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2\"></path>\n        </svg>\n      ) : (\n        <svg\n          xmlns=\"http://www.w3.org/2000/svg\"\n          width=\"24\"\n          height=\"24\"\n          viewBox=\"0 0 24 24\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          stroke-width=\"2\"\n          stroke-linecap=\"round\"\n          stroke-linejoin=\"round\"\n          className=\"mr-2 size-4\"\n        >\n          <polyline points=\"20 6 9 17 4 12\"></polyline>\n        </svg>\n      )}\n    </Button>\n  );\n};\n\nexport default Copy;\n","/*!\n * @kurkle/color v0.3.4\n * https://github.com/kurkle/color#readme\n * (c) 2024 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n\tx: 'dark',\n\tZ: 'light',\n\tY: 're',\n\tX: 'blu',\n\tW: 'gr',\n\tV: 'medium',\n\tU: 'slate',\n\tA: 'ee',\n\tT: 'ol',\n\tS: 'or',\n\tB: 'ra',\n\tC: 'lateg',\n\tD: 'ights',\n\tR: 'in',\n\tQ: 'turquois',\n\tE: 'hi',\n\tP: 'ro',\n\tO: 'al',\n\tN: 'le',\n\tM: 'de',\n\tL: 'yello',\n\tF: 'en',\n\tK: 'ch',\n\tG: 'arks',\n\tH: 'ea',\n\tI: 'ightg',\n\tJ: 'wh'\n};\nconst names$1 = {\n\tOiceXe: 'f0f8ff',\n\tantiquewEte: 'faebd7',\n\taqua: 'ffff',\n\taquamarRe: '7fffd4',\n\tazuY: 'f0ffff',\n\tbeige: 'f5f5dc',\n\tbisque: 'ffe4c4',\n\tblack: '0',\n\tblanKedOmond: 'ffebcd',\n\tXe: 'ff',\n\tXeviTet: '8a2be2',\n\tbPwn: 'a52a2a',\n\tburlywood: 'deb887',\n\tcaMtXe: '5f9ea0',\n\tKartYuse: '7fff00',\n\tKocTate: 'd2691e',\n\tcSO: 'ff7f50',\n\tcSnflowerXe: '6495ed',\n\tcSnsilk: 'fff8dc',\n\tcrimson: 'dc143c',\n\tcyan: 'ffff',\n\txXe: '8b',\n\txcyan: '8b8b',\n\txgTMnPd: 'b8860b',\n\txWay: 'a9a9a9',\n\txgYF: '6400',\n\txgYy: 'a9a9a9',\n\txkhaki: 'bdb76b',\n\txmagFta: '8b008b',\n\txTivegYF: '556b2f',\n\txSange: 'ff8c00',\n\txScEd: '9932cc',\n\txYd: '8b0000',\n\txsOmon: 'e9967a',\n\txsHgYF: '8fbc8f',\n\txUXe: '483d8b',\n\txUWay: '2f4f4f',\n\txUgYy: '2f4f4f',\n\txQe: 'ced1',\n\txviTet: '9400d3',\n\tdAppRk: 'ff1493',\n\tdApskyXe: 'bfff',\n\tdimWay: '696969',\n\tdimgYy: '696969',\n\tdodgerXe: '1e90ff',\n\tfiYbrick: 'b22222',\n\tflSOwEte: 'fffaf0',\n\tfoYstWAn: '228b22',\n\tfuKsia: 'ff00ff',\n\tgaRsbSo: 'dcdcdc',\n\tghostwEte: 'f8f8ff',\n\tgTd: 'ffd700',\n\tgTMnPd: 'daa520',\n\tWay: '808080',\n\tgYF: '8000',\n\tgYFLw: 'adff2f',\n\tgYy: '808080',\n\thoneyMw: 'f0fff0',\n\thotpRk: 'ff69b4',\n\tRdianYd: 'cd5c5c',\n\tRdigo: '4b0082',\n\tivSy: 'fffff0',\n\tkhaki: 'f0e68c',\n\tlavFMr: 'e6e6fa',\n\tlavFMrXsh: 'fff0f5',\n\tlawngYF: '7cfc00',\n\tNmoncEffon: 'fffacd',\n\tZXe: 'add8e6',\n\tZcSO: 'f08080',\n\tZcyan: 'e0ffff',\n\tZgTMnPdLw: 'fafad2',\n\tZWay: 'd3d3d3',\n\tZgYF: '90ee90',\n\tZgYy: 'd3d3d3',\n\tZpRk: 'ffb6c1',\n\tZsOmon: 'ffa07a',\n\tZsHgYF: '20b2aa',\n\tZskyXe: '87cefa',\n\tZUWay: '778899',\n\tZUgYy: '778899',\n\tZstAlXe: 'b0c4de',\n\tZLw: 'ffffe0',\n\tlime: 'ff00',\n\tlimegYF: '32cd32',\n\tlRF: 'faf0e6',\n\tmagFta: 'ff00ff',\n\tmaPon: '800000',\n\tVaquamarRe: '66cdaa',\n\tVXe: 'cd',\n\tVScEd: 'ba55d3',\n\tVpurpN: '9370db',\n\tVsHgYF: '3cb371',\n\tVUXe: '7b68ee',\n\tVsprRggYF: 'fa9a',\n\tVQe: '48d1cc',\n\tVviTetYd: 'c71585',\n\tmidnightXe: '191970',\n\tmRtcYam: 'f5fffa',\n\tmistyPse: 'ffe4e1',\n\tmoccasR: 'ffe4b5',\n\tnavajowEte: 'ffdead',\n\tnavy: '80',\n\tTdlace: 'fdf5e6',\n\tTive: '808000',\n\tTivedBb: '6b8e23',\n\tSange: 'ffa500',\n\tSangeYd: 'ff4500',\n\tScEd: 'da70d6',\n\tpOegTMnPd: 'eee8aa',\n\tpOegYF: '98fb98',\n\tpOeQe: 'afeeee',\n\tpOeviTetYd: 'db7093',\n\tpapayawEp: 'ffefd5',\n\tpHKpuff: 'ffdab9',\n\tperu: 'cd853f',\n\tpRk: 'ffc0cb',\n\tplum: 'dda0dd',\n\tpowMrXe: 'b0e0e6',\n\tpurpN: '800080',\n\tYbeccapurpN: '663399',\n\tYd: 'ff0000',\n\tPsybrown: 'bc8f8f',\n\tPyOXe: '4169e1',\n\tsaddNbPwn: '8b4513',\n\tsOmon: 'fa8072',\n\tsandybPwn: 'f4a460',\n\tsHgYF: '2e8b57',\n\tsHshell: 'fff5ee',\n\tsiFna: 'a0522d',\n\tsilver: 'c0c0c0',\n\tskyXe: '87ceeb',\n\tUXe: '6a5acd',\n\tUWay: '708090',\n\tUgYy: '708090',\n\tsnow: 'fffafa',\n\tsprRggYF: 'ff7f',\n\tstAlXe: '4682b4',\n\ttan: 'd2b48c',\n\tteO: '8080',\n\ttEstN: 'd8bfd8',\n\ttomato: 'ff6347',\n\tQe: '40e0d0',\n\tviTet: 'ee82ee',\n\tJHt: 'f5deb3',\n\twEte: 'ffffff',\n\twEtesmoke: 'f5f5f5',\n\tLw: 'ffff00',\n\tLwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","/*!\n * Chart.js v4.5.0\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\nimport { Color } from '@kurkle/color';\n\n/**\n * @namespace Chart.helpers\n */ /**\n * An empty function that can be used, for example, for optional callback.\n */ function noop() {\n/* noop */ }\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */ const uid = (()=>{\n    let id = 0;\n    return ()=>id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isNullOrUndef(value) {\n    return value === null || value === undefined;\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */ function isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */ function isNumberFinite(value) {\n    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */ function finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */ function valueOrDefault(value, defaultValue) {\n    return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */ function callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === 'function') {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */ function _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */ function clone(source) {\n    if (isArray(source)) {\n        return source.map(clone);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        '__proto__',\n        'prototype',\n        'constructor'\n    ].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */ function _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    let current;\n    for(let i = 0; i < ilen; ++i){\n        current = sources[i];\n        if (!isObject(current)) {\n            continue;\n        }\n        const keys = Object.keys(current);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, current, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */ function _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone(sval);\n    }\n}\n/**\n * @private\n */ function _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n    '': (v)=>v,\n    // default resolvers\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\n/**\n * @private\n */ function _splitKey(key) {\n    const parts = key.split('.');\n    const keys = [];\n    let tmp = '';\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith('\\\\')) {\n            tmp = tmp.slice(0, -1) + '.';\n        } else {\n            keys.push(tmp);\n            tmp = '';\n        }\n    }\n    return keys;\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === '') {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\n/**\n * @private\n */ function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== 'undefined';\nconst isFunction = (value)=>typeof value === 'function';\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param e - The event\n * @private\n */ function _isClickEvent(e) {\n    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */ const PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */ function niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */ function _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\n/**\n * Verifies that attempting to coerce n to string or number won't throw a TypeError.\n */ function isNonPrimitive(n) {\n    return typeof n === 'symbol' || typeof n === 'object' && n !== null && !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n);\n}\nfunction isNumber(n) {\n    return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */ function _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */ function _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */ function _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */ function _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */ function _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */ function _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */ function _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\n        const ti = table[index][key];\n        return ti < value || ti === value && table[index + 1][key] === value;\n    } : (index)=>table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */ function _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    'push',\n    'pop',\n    'shift',\n    'splice',\n    'unshift'\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, '_chartjs', {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = '_onData' + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === 'function') {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\n/**\n * @param items\n */ function _arrayUnique(items) {\n    const set = new Set(items);\n    if (set.size === items.length) {\n        return items;\n    }\n    return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n/**\n* Request animation polyfill\n*/ const requestAnimFrame = function() {\n    if (typeof window === 'undefined') {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */ function throttled(fn, thisArg) {\n    let argsToUse = [];\n    let ticking = false;\n    return function(...args) {\n        // Save the args for use later\n        argsToUse = args;\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, argsToUse);\n            });\n        }\n    };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */ function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */ const _textX = (align, left, right, rtl)=>{\n    const check = rtl ? 'left' : 'right';\n    return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale , vScale , _parsed  } = meta;\n        const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n        const axis = iScale.axis;\n        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n        if (minDefined) {\n            start = Math.min(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo);\n            if (spanGaps) {\n                const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                start -= Math.max(0, distanceToDefinedLo);\n            }\n            start = _limitValue(start, 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            let end = Math.max(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1);\n            if (spanGaps) {\n                const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                end += Math.max(0, distanceToDefinedHi);\n            }\n            count = _limitValue(end, start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */ function _scaleRangesChanged(meta) {\n    const { xScale , yScale , _scaleRanges  } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\n\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */ const effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === 'object') {\n        const type = value.toString();\n        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : new Color(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst numbers = [\n    'x',\n    'y',\n    'borderWidth',\n    'radius',\n    'tension'\n];\nconst colors = [\n    'color',\n    'borderColor',\n    'backgroundColor'\n];\nfunction applyAnimationsDefaults(defaults) {\n    defaults.set('animation', {\n        delay: undefined,\n        duration: 1000,\n        easing: 'easeOutQuart',\n        fn: undefined,\n        from: undefined,\n        loop: undefined,\n        to: undefined,\n        type: undefined\n    });\n    defaults.describe('animation', {\n        _fallback: false,\n        _indexable: false,\n        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n    });\n    defaults.set('animations', {\n        colors: {\n            type: 'color',\n            properties: colors\n        },\n        numbers: {\n            type: 'number',\n            properties: numbers\n        }\n    });\n    defaults.describe('animations', {\n        _fallback: 'animation'\n    });\n    defaults.set('transitions', {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    easing: 'linear',\n                    fn: (v)=>v | 0\n                }\n            }\n        }\n    });\n}\n\nfunction applyLayoutsDefaults(defaults) {\n    defaults.set('layout', {\n        autoPadding: true,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\n\nconst formatters = {\n values (value) {\n        return isArray(value) ?  value : '' + value;\n    },\n numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = 'scientific';\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = log10(Math.abs(delta));\n        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return formatNumber(tickValue, locale, options);\n    },\n logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n        if ([\n            1,\n            2,\n            3,\n            5,\n            10,\n            15\n        ].includes(remain) || index > 0.8 * ticks.length) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return '';\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\n var Ticks = {\n    formatters\n};\n\nfunction applyScaleDefaults(defaults) {\n    defaults.set('scale', {\n        display: true,\n        offset: false,\n        reverse: false,\n        beginAtZero: false,\n bounds: 'ticks',\n        clip: true,\n grace: 0,\n        grid: {\n            display: true,\n            lineWidth: 1,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickLength: 8,\n            tickWidth: (_ctx, options)=>options.lineWidth,\n            tickColor: (_ctx, options)=>options.color,\n            offset: false\n        },\n        border: {\n            display: true,\n            dash: [],\n            dashOffset: 0.0,\n            width: 1\n        },\n        title: {\n            display: false,\n            text: '',\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            textStrokeWidth: 0,\n            textStrokeColor: '',\n            padding: 3,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {},\n            align: 'center',\n            crossAlign: 'near',\n            showLabelBackdrop: false,\n            backdropColor: 'rgba(255, 255, 255, 0.75)',\n            backdropPadding: 2\n        }\n    });\n    defaults.route('scale.ticks', 'color', '', 'color');\n    defaults.route('scale.grid', 'color', '', 'borderColor');\n    defaults.route('scale.border', 'color', '', 'borderColor');\n    defaults.route('scale.title', 'color', '', 'color');\n    defaults.describe('scale', {\n        _fallback: false,\n        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'\n    });\n    defaults.describe('scales', {\n        _fallback: 'scale'\n    });\n    defaults.describe('scale.ticks', {\n        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',\n        _indexable: (name)=>name !== 'backdropPadding'\n    });\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\n function getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split('.');\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === 'string') {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, ''), scope);\n}\n class Defaults {\n    constructor(_descriptors, _appliers){\n        this.animation = undefined;\n        this.backgroundColor = 'rgba(0,0,0,0.1)';\n        this.borderColor = 'rgba(0,0,0,0.1)';\n        this.color = '#666';\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            'mousemove',\n            'mouseout',\n            'click',\n            'touchstart',\n            'touchmove'\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: 'normal',\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = 'x';\n        this.interaction = {\n            mode: 'nearest',\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n        this.apply(_appliers);\n    }\n set(scope, values) {\n        return set(this, scope, values);\n    }\n get(scope) {\n        return getScope$1(this, scope);\n    }\n describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = '_' + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    apply(appliers) {\n        appliers.forEach((apply)=>apply(this));\n    }\n}\nvar defaults = /* #__PURE__ */ new Defaults({\n    _scriptable: (name)=>!name.startsWith('on'),\n    _indexable: (name)=>name !== 'events',\n    hover: {\n        _fallback: 'interaction'\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n}, [\n    applyAnimationsDefaults,\n    applyLayoutsDefaults,\n    applyScaleDefaults\n]);\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */ function toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n/**\n * @private\n */ function _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\n/**\n * @private\n */ // eslint-disable-next-line complexity\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        // Undefined strings and arrays should not be measured\n        if (thing !== undefined && thing !== null && !isArray(thing)) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            // if it is an array lets measure each element\n            // to do maybe simplify this function a bit so we can do this more recursively?\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                // Undefined strings and arrays should not be measured\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */ function _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n/**\n * Clears the entire canvas.\n */ function clearCanvas(canvas, ctx) {\n    if (!ctx && !canvas) {\n        return;\n    }\n    ctx = ctx || canvas.getContext('2d');\n    ctx.save();\n    // canvas.width and canvas.height do not consider the canvas transform,\n    // while clearRect does\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    drawPointLegend(ctx, options, x, y, null);\n}\n// eslint-disable-next-line complexity\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === 'object') {\n        type = style.toString();\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        // Default includes circle\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case 'triangle':\n            width = w ? w / 2 : radius;\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case 'rectRounded':\n            // NOTE: the rounded rect implementation changed to use `arc` instead of\n            // `quadraticCurveTo` since it generates better results when rect is\n            // almost a circle. 0.516 (instead of 0.5) produces results with visually\n            // closer proportion to the previous impl and it is inscribed in the\n            // circle with `radius`. For more details, see the following PRs:\n            // https://github.com/chartjs/Chart.js/issues/5597\n            // https://github.com/chartjs/Chart.js/issues/5858\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case 'rect':\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        /* falls through */ case 'rectRot':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            ctx.closePath();\n            break;\n        case 'crossRot':\n            rad += QUARTER_PI;\n        /* falls through */ case 'cross':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'star':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            rad += QUARTER_PI;\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'line':\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case 'dash':\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n            break;\n        case false:\n            ctx.closePath();\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */ function _isPointInArea(point, area, margin) {\n    margin = margin || 0.5; // margin - default is to match rounded decimals\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\n/**\n * @private\n */ function _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === 'middle') {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === 'after' !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\n/**\n * @private\n */ function _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */ const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction drawBackdrop(ctx, opts) {\n    const oldColor = ctx.fillStyle;\n    ctx.fillStyle = opts.color;\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n    ctx.fillStyle = oldColor;\n}\n/**\n * Render text onto the canvas\n */ function renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (opts.backdrop) {\n            drawBackdrop(ctx, opts.backdrop);\n        }\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += Number(font.lineHeight);\n    }\n    ctx.restore();\n}\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */ function addRoundedRectPath(ctx, rect) {\n    const { x , y , w , h , radius  } = rect;\n    // top left arc\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n    // line from top left to bottom left\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    // bottom left arc\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    // line from bottom left to bottom right\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    // bottom right arc\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    // line from bottom right to top right\n    ctx.lineTo(x + w, y + radius.topRight);\n    // top right arc\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    // line from top right to top left\n    ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */ function toLineHeight(value, size) {\n    const matches = ('' + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === 'normal') {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case 'px':\n            return value;\n        case '%':\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */ function toTRBL(value) {\n    return _readValueToProps(value, {\n        top: 'y',\n        right: 'x',\n        bottom: 'y',\n        left: 'x'\n    });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */ function toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        'topLeft',\n        'topRight',\n        'bottomLeft',\n        'bottomRight'\n    ]);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */ function toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */ function toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === 'string') {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !('' + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = undefined;\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: ''\n    };\n    font.string = toFontString(font);\n    return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */ function resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === 'function') {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */ function _addGrace(minmax, grace, beginAtZero) {\n    const { min , max  } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */ function _createResolver(scopes, prefixes = [\n    ''\n], rootScopes, fallback, getTarget = ()=>scopes[0]) {\n    const finalRootScopes = rootScopes || scopes;\n    if (typeof fallback === 'undefined') {\n        fallback = _resolve('_fallback', scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: 'Object',\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: finalRootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, finalRootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete target._keys; // remove cached keys\n            delete scopes[0][prop]; // remove from top level scope\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value; // set to top level scope + cache\n            delete target._keys; // remove cached keys\n            return true;\n        }\n    });\n}\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete proxy[prop]; // remove from proxy\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            proxy[prop] = value; // set to proxy\n            delete target[prop]; // remove from cache\n            return true;\n        }\n    });\n}\n/**\n * @private\n */ function _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n        return target[prop];\n    }\n    const value = resolve();\n    // cache the resolved value\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    let value = _proxy[prop]; // resolve from proxy\n    // resolve with context\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        // if the resolved value is an object, create a sub resolver for it\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n    const { _proxy , _context , _subProxy , _stack  } = target;\n    if (_stack.has(prop)) {\n        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n    }\n    _stack.add(prop);\n    let value = getValue(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        // When scriptable option returns an object, create a resolver on that.\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n        return value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        // Array of objects, return array or resolvers\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n                // When we reach the descriptor that defines a new _fallback, return that.\n                // The fallback will resume to that new scope.\n                return fallback;\n            }\n        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n            // Fallback to `false` results to `false`, when falling back to different key.\n            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (typeof fallback !== 'undefined' && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        ''\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        // For array of objects, the object is used to store updated values\n        return value;\n    }\n    return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (typeof value !== 'undefined') {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale  } = meta;\n    const { key ='r'  } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n    // This function must also respect \"skipped\" points\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    // If all points are the same, s01 & s02 will be inf\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01; // scaling factor for triangle Ta\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */ function monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\n/**\n * This function calculates Bézier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */ function splineCurveMonotone(points, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    // Calculate slopes (deltaK) and initialize tangents (mK)\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\n/**\n * @private\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    // Only consider points that are drawn in case the spanGaps option is used\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === 'monotone') {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\n\n/**\n * @private\n */ function _isDomSupported() {\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * @private\n */ function _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === '[object ShadowRoot]') {\n        parent = parent.host;\n    }\n    return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */ function parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === 'string') {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf('%') !== -1) {\n            // percentage * size in dimension\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    'top',\n    'right',\n    'bottom',\n    'left'\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? '-' + suffix : '';\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */ function getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX , offsetY  } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */ function getRelativePosition(event, chart) {\n    if ('native' in event) {\n        return event;\n    }\n    const { canvas , currentDevicePixelRatio  } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === 'border-box';\n    const paddings = getPositionedStyle(style, 'padding');\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const { x , y , box  } = getCanvasPosition(event, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width , height  } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = canvas && _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n            const containerPadding = getPositionedStyle(containerStyle, 'padding');\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, 'margin');\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width , height  } = containerSize;\n    if (style.boxSizing === 'content-box') {\n        const borders = getPositionedStyle(style, 'border', 'width');\n        const paddings = getPositionedStyle(style, 'padding');\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        // https://github.com/chartjs/Chart.js/issues/4659\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n        height = round1(width / 2);\n    }\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n        height = containerSize.height;\n        width = round1(Math.floor(height * aspectRatio));\n    }\n    return {\n        width,\n        height\n    };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */ function retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = Math.floor(chart.height * pixelRatio);\n    const deviceWidth = Math.floor(chart.width * pixelRatio);\n    chart.height = Math.floor(chart.height);\n    chart.width = Math.floor(chart.width);\n    const canvas = chart.canvas;\n    // If no style has been set on the canvas, the render size is used as display size,\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n    // See https://github.com/chartjs/Chart.js/issues/3575\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */ const supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        if (_isDomSupported()) {\n            window.addEventListener('test', null, options);\n            window.removeEventListener('test', null, options);\n        }\n    } catch (e) {\n    // continue regardless of error\n    }\n    return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */ function readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\n\n/**\n * @private\n */ function _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\n/**\n * @private\n */ function _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\n/**\n * @private\n */ function _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === 'center') {\n                return align;\n            }\n            return align === 'right' ? 'left' : 'right';\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === 'ltr' || direction === 'rtl') {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue('direction'),\n            style.getPropertyPriority('direction')\n        ];\n        style.setProperty('direction', direction, 'important');\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty('direction', original[0], original[1]);\n    }\n}\n\nfunction propertyFn(property) {\n    if (property === 'angle') {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start , end , count , loop , style  }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property , start: startBound , end: endBound  } = bounds;\n    const { between , normalize  } = propertyFn(property);\n    const count = points.length;\n    let { start , end , loop  } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\n function _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property , start: startBound , end: endBound  } = bounds;\n    const count = points.length;\n    const { compare , between , normalize  } = propertyFn(property);\n    const { start , end , loop , style  } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\n function _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\n function findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\n function solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\n function _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n function splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\n function doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: 'segment',\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    if (!prevStyle) {\n        return false;\n    }\n    const cache = [];\n    const replacer = function(key, value) {\n        if (!isPatternOrGradient(value)) {\n            return value;\n        }\n        if (!cache.includes(value)) {\n            cache.push(value);\n        }\n        return cache.indexOf(value);\n    };\n    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n\nfunction getSizeForArea(scale, chartArea, field) {\n    return scale.options.clip ? scale[field] : chartArea[field];\n}\nfunction getDatasetArea(meta, chartArea) {\n    const { xScale , yScale  } = meta;\n    if (xScale && yScale) {\n        return {\n            left: getSizeForArea(xScale, chartArea, 'left'),\n            right: getSizeForArea(xScale, chartArea, 'right'),\n            top: getSizeForArea(yScale, chartArea, 'top'),\n            bottom: getSizeForArea(yScale, chartArea, 'bottom')\n        };\n    }\n    return chartArea;\n}\nfunction getDatasetClipArea(chart, meta) {\n    const clip = meta._clip;\n    if (clip.disabled) {\n        return false;\n    }\n    const area = getDatasetArea(meta, chart.chartArea);\n    return {\n        left: clip.left === false ? 0 : area.left - (clip.left === true ? 0 : clip.left),\n        right: clip.right === false ? chart.width : area.right + (clip.right === true ? 0 : clip.right),\n        top: clip.top === false ? 0 : area.top - (clip.top === true ? 0 : clip.top),\n        bottom: clip.bottom === false ? chart.height : area.bottom + (clip.bottom === true ? 0 : clip.bottom)\n    };\n}\n\nexport { unclipArea as $, _rlookupByKey as A, _lookupByKey as B, _isPointInArea as C, getAngleFromPoint as D, toPadding as E, each as F, getMaximumSize as G, HALF_PI as H, _getParentNode as I, readUsedSize as J, supportsEventListenerOptions as K, throttled as L, _isDomSupported as M, _factorize as N, finiteOrDefault as O, PI as P, callback as Q, _addGrace as R, _limitValue as S, TAU as T, toDegrees as U, _measureText as V, _int16Range as W, _alignPixel as X, clipArea as Y, renderText as Z, _arrayUnique as _, resolve as a, getStyle as a$, toFont as a0, _toLeftRightCenter as a1, _alignStartEnd as a2, overrides as a3, merge as a4, _capitalize as a5, descriptors as a6, isFunction as a7, _attachContext as a8, _createResolver as a9, getRtlAdapter as aA, overrideTextDirection as aB, _textX as aC, restoreTextDirection as aD, drawPointLegend as aE, distanceBetweenPoints as aF, noop as aG, _setMinAndMaxByKey as aH, niceNum as aI, almostWhole as aJ, almostEquals as aK, _decimalPlaces as aL, Ticks as aM, log10 as aN, _longestText as aO, _filterBetween as aP, _lookup as aQ, isPatternOrGradient as aR, getHoverColor as aS, clone as aT, _merger as aU, _mergerIf as aV, _deprecated as aW, _splitKey as aX, toFontString as aY, splineCurve as aZ, splineCurveMonotone as a_, _descriptors as aa, mergeIf as ab, uid as ac, debounce as ad, retinaScale as ae, clearCanvas as af, setsEqual as ag, getDatasetClipArea as ah, _elementsEqual as ai, _isClickEvent as aj, _isBetween as ak, _normalizeAngle as al, _readValueToProps as am, _updateBezierControlPoints as an, _computeSegments as ao, _boundSegments as ap, _steppedInterpolation as aq, _bezierInterpolation as ar, _pointInLine as as, _steppedLineTo as at, _bezierCurveTo as au, drawPoint as av, addRoundedRectPath as aw, toTRBL as ax, toTRBLCorners as ay, _boundSegment as az, isArray as b, fontString as b0, toLineHeight as b1, PITAU as b2, INFINITY as b3, RAD_PER_DEG as b4, QUARTER_PI as b5, TWO_THIRDS_PI as b6, _angleDiff as b7, color as c, defaults as d, effects as e, resolveObjectKey as f, isNumberFinite as g, defined as h, isObject as i, createContext as j, isNullOrUndef as k, listenArrayEvents as l, toPercentage as m, toDimension as n, formatNumber as o, _angleBetween as p, _getStartAndCountOfVisiblePoints as q, requestAnimFrame as r, sign as s, toRadians as t, unlistenArrayEvents as u, valueOrDefault as v, _scaleRangesChanged as w, isNumber as x, _parseObjectDataRadialScale as y, getRelativePosition as z };\n//# sourceMappingURL=helpers.dataset.js.map\n","/*!\n * Chart.js v4.5.0\n * https://www.chartjs.org\n * (c) 2025 Chart.js Contributors\n * Released under the MIT License\n */\nimport { r as requestAnimFrame, a as resolve, e as effects, c as color, i as isObject, d as defaults, b as isArray, v as valueOrDefault, u as unlistenArrayEvents, l as listenArrayEvents, f as resolveObjectKey, g as isNumberFinite, h as defined, s as sign, j as createContext, k as isNullOrUndef, _ as _arrayUnique, t as toRadians, m as toPercentage, n as toDimension, T as TAU, o as formatNumber, p as _angleBetween, H as HALF_PI, P as PI, q as _getStartAndCountOfVisiblePoints, w as _scaleRangesChanged, x as isNumber, y as _parseObjectDataRadialScale, z as getRelativePosition, A as _rlookupByKey, B as _lookupByKey, C as _isPointInArea, D as getAngleFromPoint, E as toPadding, F as each, G as getMaximumSize, I as _getParentNode, J as readUsedSize, K as supportsEventListenerOptions, L as throttled, M as _isDomSupported, N as _factorize, O as finiteOrDefault, Q as callback, R as _addGrace, S as _limitValue, U as toDegrees, V as _measureText, W as _int16Range, X as _alignPixel, Y as clipArea, Z as renderText, $ as unclipArea, a0 as toFont, a1 as _toLeftRightCenter, a2 as _alignStartEnd, a3 as overrides, a4 as merge, a5 as _capitalize, a6 as descriptors, a7 as isFunction, a8 as _attachContext, a9 as _createResolver, aa as _descriptors, ab as mergeIf, ac as uid, ad as debounce, ae as retinaScale, af as clearCanvas, ag as setsEqual, ah as getDatasetClipArea, ai as _elementsEqual, aj as _isClickEvent, ak as _isBetween, al as _normalizeAngle, am as _readValueToProps, an as _updateBezierControlPoints, ao as _computeSegments, ap as _boundSegments, aq as _steppedInterpolation, ar as _bezierInterpolation, as as _pointInLine, at as _steppedLineTo, au as _bezierCurveTo, av as drawPoint, aw as addRoundedRectPath, ax as toTRBL, ay as toTRBLCorners, az as _boundSegment, aA as getRtlAdapter, aB as overrideTextDirection, aC as _textX, aD as restoreTextDirection, aE as drawPointLegend, aF as distanceBetweenPoints, aG as noop, aH as _setMinAndMaxByKey, aI as niceNum, aJ as almostWhole, aK as almostEquals, aL as _decimalPlaces, aM as Ticks, aN as log10, aO as _longestText, aP as _filterBetween, aQ as _lookup } from './chunks/helpers.dataset.js';\nimport '@kurkle/color';\n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = requestAnimFrame.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, 'progress');\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, 'complete');\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), 'complete');\n    }\n remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = /* #__PURE__ */ new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n color (from, to, factor) {\n        const c0 = color(from || transparent);\n        const c1 = c0.valid && color(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = resolve([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = resolve([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = effects[cfg.easing] || effects.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = resolve([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = resolve([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? 'res' : 'rej';\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\n\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!isObject(config)) {\n            return;\n        }\n        const animationOptions = Object.keys(defaults.animation);\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!isObject(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            (isArray(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{\n            });\n        }\n        return animations;\n    }\n _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === '$') {\n                continue;\n            }\n            if (prop === 'options') {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if (isObject(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === 'single';\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    let found = false;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            found = true;\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {\n            value += otherValue;\n        }\n    }\n    if (!found && !options.all) {\n        return 0;\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data, meta) {\n    const { iScale , vScale  } = meta;\n    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            [iAxisKey]: key,\n            [vAxisKey]: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart , _cachedMeta: meta  } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale , vScale , index: datasetIndex  } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index , [vAxis]: value  } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n        const visualValues = stack._visualValues || (stack._visualValues = {});\n        visualValues[datasetIndex] = value;\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return createContext(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: 'default',\n        type: 'dataset'\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return createContext(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: 'default',\n        type: 'data'\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n            delete stacks[axis]._visualValues[datasetIndex];\n        }\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n static defaults = {};\n static datasetElementType = null;\n static dataElementType = null;\n constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n         this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.datasetElementType = new.target.datasetElementType;\n        this.dataElementType = new.target.dataElementType;\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;\n        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update('reset');\n    }\n _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            unlistenArrayEvents(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if (isObject(data)) {\n            const meta = this._cachedMeta;\n            this._data = convertObjectDataToArray(data, meta);\n        } else if (_data !== data) {\n            if (_data) {\n                unlistenArrayEvents(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                listenArrayEvents(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n            meta._stacked = isStacked(meta.vScale, meta);\n        }\n    }\n configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n parse(start, count) {\n        const { _cachedMeta: meta , _data: data  } = this;\n        const { iScale , _stacked  } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if (isArray(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if (isObject(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n                y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]._visualValues\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if (isNumberFinite(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n getMaxOverflow() {\n        return false;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n        };\n    }\n _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || 'default');\n        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n getStyle(index, active) {\n        const mode = active ? 'active' : 'default';\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n _resolveElementOptions(elementType, mode = 'default', index) {\n        const active = mode === 'active';\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + '-' + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && defined(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            'hover',\n            elementType,\n            ''\n        ] : [\n            elementType,\n            ''\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(defaults.elements[elementType]);\n        const context = ()=>this.getContext(index, active, mode);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', true);\n    }\n _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', false);\n        }\n    }\n _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', true);\n        }\n    }\n _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, 'reset');\n        }\n    }\n    updateElements(element, start, count, mode) {}\n _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            '_insertElements',\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            '_removeElements',\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            '_removeElements',\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                '_removeElements',\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                '_insertElements',\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            '_insertElements',\n            0,\n            arguments.length\n        ]);\n    }\n}\n\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\n function computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if (defined(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\n function computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if (isNullOrUndef(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\n function computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if (isArray(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return sign(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = 'left';\n        end = 'right';\n    } else {\n        reverse = properties.base < properties.y;\n        start = 'bottom';\n        end = 'top';\n    }\n    if (reverse) {\n        top = 'end';\n        bottom = 'start';\n    } else {\n        top = 'start';\n        bottom = 'end';\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start , end , reverse , top , bottom  } = borderProps(properties);\n    if (edge === 'middle' && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount  }, ratio) {\n    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    static id = 'bar';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'bar',\n        categoryPercentage: 0.8,\n        barPercentage: 0.9,\n        grouped: true,\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'base',\n                    'width',\n                    'height'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category',\n                offset: true,\n                grid: {\n                    offset: true\n                }\n            },\n            _value_: {\n                type: 'linear',\n                beginAtZero: true\n            }\n        }\n    };\n parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseObjectData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n getMaxOverflow() {\n        return 0;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale , vScale  } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === 'reset';\n        const { index , _cachedMeta: { vScale  }  } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n _getStacks(last, dataIndex) {\n        const { iScale  } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n        const iScaleValue = currentParsed && currentParsed[iScale.axis];\n        const skipNull = (meta)=>{\n            const parsed = meta._parsed.find((item)=>item[iScale.axis] === iScaleValue);\n            const val = parsed && parsed[meta.vScale.axis];\n            if (isNullOrUndef(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n    _getAxisCount() {\n        return this._getAxis().length;\n    }\n    getFirstScaleIdForIndexAxis() {\n        const scales = this.chart.scales;\n        const indexScaleId = this.chart.options.indexAxis;\n        return Object.keys(scales).filter((key)=>scales[key].axis === indexScaleId).shift();\n    }\n    _getAxis() {\n        const axis = {};\n        const firstScaleAxisId = this.getFirstScaleIdForIndexAxis();\n        for (const dataset of this.chart.data.datasets){\n            axis[valueOrDefault(this.chart.options.indexAxis === 'x' ? dataset.xAxisID : dataset.yAxisID, firstScaleAxisId)] = true;\n        }\n        return Object.keys(axis);\n    }\n _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n            if (_stacked && !floating) {\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n            }\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n        let center, size;\n        const axisCount = this._getAxisCount();\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount * axisCount) : computeFitCategoryTraits(index, ruler, options, stackCount * axisCount);\n            const axisID = this.chart.options.indexAxis === 'x' ? this.getDataset().xAxisID : this.getDataset().yAxisID;\n            const axisNumber = this._getAxis().indexOf(valueOrDefault(axisID, this.getFirstScaleIdForIndexAxis()));\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined) + axisNumber;\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\n\nclass BubbleController extends DatasetController {\n    static id = 'bubble';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'borderWidth',\n                    'radius'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== 'active') {\n            values.radius = 0;\n        }\n        values.radius += valueOrDefault(parsed && parsed._custom, radius);\n        return values;\n    }\n}\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < TAU) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(HALF_PI, startY, endY);\n        const minX = calcMin(PI, startX, endX);\n        const minY = calcMin(PI + HALF_PI, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    static id = 'doughnut';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: false\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'circumference',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius',\n                    'startAngle',\n                    'x',\n                    'y',\n                    'offset',\n                    'borderWidth',\n                    'spacing'\n                ]\n            }\n        },\n        cutout: '50%',\n        rotation: 0,\n        circumference: 360,\n        radius: '100%',\n        spacing: 0,\n        indexAxis: 'r'\n    };\n    static descriptors = {\n        _scriptable: (name)=>name !== 'spacing',\n        _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if (isObject(data[start])) {\n                const { key ='value'  } = this._parsing;\n                getter = (i)=>+resolveObjectKey(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n _getRotation() {\n        return toRadians(this.options.rotation - 90);\n    }\n _getCircumference() {\n        return toRadians(this.options.circumference);\n    }\n _getRotationExtents() {\n        let min = TAU;\n        let max = -TAU;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n update(mode) {\n        const chart = this.chart;\n        const { chartArea  } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference , rotation  } = this._getRotationExtents();\n        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = toDimension(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return TAU * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== 'inner') {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n _getRingWeight(datasetIndex) {\n        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\n\nclass LineController extends DatasetController {\n    static id = 'line';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        showLine: true,\n        spanGaps: false\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category'\n            },\n            _value_: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line , data: points = [] , _dataset  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        const end = start + count;\n        const pointsCount = points.length;\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = 0; i < pointsCount; ++i){\n            const point = points[i];\n            const properties = directUpdate ? point : {};\n            if (i < start || i >= end) {\n                properties.skip = true;\n                continue;\n            }\n            const parsed = this.getParsed(i);\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\n\nclass PolarAreaController extends DatasetController {\n    static id = 'polarArea';\n static defaults = {\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: true\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'startAngle',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius'\n                ]\n            }\n        },\n        indexAxis: 'r',\n        startAngle: 0\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        },\n        scales: {\n            r: {\n                type: 'radialLinear',\n                angleLines: {\n                    display: false\n                },\n                beginAtZero: true,\n                grid: {\n                    circular: true\n                },\n                pointLabels: {\n                    display: false\n                },\n                startAngle: 0\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\n\nclass PieController extends DoughnutController {\n    static id = 'pie';\n static defaults = {\n        cutout: 0,\n        rotation: 0,\n        circumference: 360,\n        radius: '100%'\n    };\n}\n\nclass RadarController extends DatasetController {\n    static id = 'radar';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        indexAxis: 'r',\n        showLine: true,\n        elements: {\n            line: {\n                fill: 'start'\n            }\n        }\n    };\n static overrides = {\n        aspectRatio: 1,\n        scales: {\n            r: {\n                type: 'radialLinear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== 'resize') {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === 'reset';\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\n\nclass ScatterController extends DatasetController {\n    static id = 'scatter';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        showLine: false,\n        fill: false\n    };\n static overrides = {\n        interaction: {\n            mode: 'point'\n        },\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + ')'\n        };\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = []  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            if (!this.datasetElementType) {\n                this.addElements();\n            }\n            const { dataset: line , _dataset  } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        } else if (this.datasetElementType) {\n            delete meta.dataset;\n            this.datasetElementType = false;\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine  } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = this.chart.registry.getElement('line');\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPieController: PieController,\nPolarAreaController: PolarAreaController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\n/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */ function abstract() {\n    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */ class DateAdapterBase {\n    /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */ static override(members) {\n        Object.assign(DateAdapterBase.prototype, members);\n    }\n    options;\n    constructor(options){\n        this.options = options || {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    init() {}\n    formats() {\n        return abstract();\n    }\n    parse() {\n        return abstract();\n    }\n    format() {\n        return abstract();\n    }\n    add() {\n        return abstract();\n    }\n    diff() {\n        return abstract();\n    }\n    startOf() {\n        return abstract();\n    }\n    endOf() {\n        return abstract();\n    }\n}\nvar adapters = {\n    _date: DateAdapterBase\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller , data , _sorted  } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n        if (!intersect) {\n            const result = lookupMethod(data, axis, value);\n            if (spanGaps) {\n                const { vScale  } = controller._cachedMeta;\n                const { _parsed  } = metaset;\n                const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                result.lo -= Math.max(0, distanceToDefinedLo);\n                const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point)=>!isNullOrUndef(point[vScale.axis]));\n                result.hi += Math.max(0, distanceToDefinedHi);\n            }\n            return result;\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === 'function' && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\n function evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index , data  } = metasets[i];\n        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\n function getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf('x') !== -1;\n    const useY = axis.indexOf('y') !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\n function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\n function getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle , endAngle  } = element.getProps([\n            'startAngle',\n            'endAngle'\n        ], useFinalPosition);\n        const { angle  } = getAngleFromPoint(element, {\n            x: position.x,\n            y: position.y\n        });\n        if (_angleBetween(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n function getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\n var Interaction = {\n    evaluateInteractionItems,\n    modes: {\n index (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'x';\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n dataset (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n point (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n nearest (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n x (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n        },\n y (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n        }\n    }\n};\n\nconst STATIC_POSITIONS = [\n    'left',\n    'top',\n    'right',\n    'bottom'\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos , options: { stack , stackWeight =1  }  } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack , pos , stackWeight  } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\n function setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth , hBoxMaxHeight  } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize  } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos , box  } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!isObject(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos('top');\n    chartArea.x += updatePos('left');\n    updatePos('right');\n    updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        'left',\n        'right'\n    ]) : marginForPositions([\n        'top',\n        'bottom'\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same , other  } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x , y  } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if (defined(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if (defined(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\nvar layouts = {\n addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || 'top';\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = toPadding(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        each(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === 'function') {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, toPadding(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        each(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\n\nclass BasePlatform {\n acquireContext(canvas, aspectRatio) {}\n releaseContext(context) {\n        return false;\n    }\n addEventListener(chart, type, listener) {}\n removeEventListener(chart, type, listener) {}\n getDevicePixelRatio() {\n        return 1;\n    }\n getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n isAttached(canvas) {\n        return true;\n    }\n updateConfig(config) {\n    }\n}\n\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext('2d') || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\n\nconst EXPANDO_KEY = '$chartjs';\n const EVENT_TYPES = {\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n};\nconst isNullOrEmpty = (value)=>value === null || value === '';\n function initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute('height');\n    const renderWidth = canvas.getAttribute('width');\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || 'block';\n    style.boxSizing = style.boxSizing || 'border-box';\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = readUsedSize(canvas, 'width');\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === '') {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = readUsedSize(canvas, 'height');\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    if (node) {\n        node.addEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction removeListener(chart, type, listener) {\n    if (chart && chart.canvas) {\n        chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x , y  } = getRelativePosition(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener('resize', onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener('resize', onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = throttled((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === 'resize') {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = throttled((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart);\n    addListener(canvas, type, proxy);\n    return proxy;\n}\n class DomPlatform extends BasePlatform {\n acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext('2d');\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            'height',\n            'width'\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if (isNullOrUndef(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n getMaximumSize(canvas, width, height, aspectRatio) {\n        return getMaximumSize(canvas, width, height, aspectRatio);\n    }\n isAttached(canvas) {\n        const container = canvas && _getParentNode(canvas);\n        return !!(container && container.isConnected);\n    }\n}\n\nfunction _detectPlatform(canvas) {\n    if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\n\nclass Element {\n    static defaults = {};\n    static defaultRoutes = undefined;\n    x;\n    y;\n    active = false;\n    options;\n    $animations;\n    tooltipPosition(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return isNumber(this.x) && isNumber(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            // let's not create an object, if not needed\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n}\n\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const determinedMaxTicks = determineMaxTicks(scale);\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\n function calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = _factorize(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\n function getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n function skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\n function skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = valueOrDefault(majorStart, 0);\n    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\n function getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\n\nconst reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);\n function sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\n function getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\n function garbageCollect(caches, length) {\n    each(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\n function getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\n function getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = toFont(options.font, fallback);\n    const padding = toPadding(options.padding);\n    const lines = isArray(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return createContext(parent, {\n        scale,\n        type: 'scale'\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return createContext(parent, {\n        tick,\n        index,\n        type: 'tick'\n    });\n}\nfunction titleAlign(align, position, reverse) {\n     let ret = _toLeftRightCenter(align);\n    if (reverse && position !== 'right' || !reverse && position === 'right') {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top , left , bottom , right , chart  } = scale;\n    const { chartArea , scales  } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = _alignStartEnd(align, left, right);\n        if (isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === 'center') {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if (isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === 'center') {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = position === 'left' ? -HALF_PI : HALF_PI;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n         this.id = cfg.id;\n         this.type = cfg.type;\n         this.options = undefined;\n         this.ctx = cfg.ctx;\n         this.chart = cfg.chart;\n         this.top = undefined;\n         this.bottom = undefined;\n         this.left = undefined;\n         this.right = undefined;\n         this.width = undefined;\n         this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n         this.maxWidth = undefined;\n         this.maxHeight = undefined;\n         this.paddingTop = undefined;\n         this.paddingBottom = undefined;\n         this.paddingLeft = undefined;\n         this.paddingRight = undefined;\n         this.axis = undefined;\n         this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n         this.ticks = [];\n         this._gridLineItems = null;\n         this._labelItems = null;\n         this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n         this._startPixel = undefined;\n         this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n parse(raw, index) {\n        return raw;\n    }\n getUserBounds() {\n        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;\n        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: finiteOrDefault(_userMin, _suggestedMin),\n            max: finiteOrDefault(_userMax, _suggestedMax),\n            minDefined: isNumberFinite(_userMin),\n            maxDefined: isNumberFinite(_userMax)\n        };\n    }\n getMinMax(canStack) {\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: finiteOrDefault(min, finiteOrDefault(max, min)),\n            max: finiteOrDefault(max, finiteOrDefault(min, max))\n        };\n    }\n getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n getTicks() {\n        return this.ticks;\n    }\n getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n getLabelItems(chartArea = this.chart.chartArea) {\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        return items;\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        callback(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n update(maxWidth, maxHeight, margins) {\n        const { beginAtZero , grace , ticks: tickOpts  } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = _addGrace(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        callback(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        callback(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        callback(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        callback(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks('beforeDataLimits');\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks('afterDataLimits');\n    }\n    beforeBuildTicks() {\n        this._callHooks('beforeBuildTicks');\n    }\n buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks('afterBuildTicks');\n    }\n    beforeTickToLabelConversion() {\n        callback(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = callback(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        callback(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        callback(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        callback(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        callback(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first , last , widest , highest  } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = toRadians(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align , padding  } , position  } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === 'start') {\n                paddingRight = last.width;\n            } else if (align === 'end') {\n                paddingLeft = first.width;\n            } else if (align !== 'inner') {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === 'start') {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === 'end') {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        callback(this.options.afterFit, [\n            this\n        ]);\n    }\n isHorizontal() {\n        const { axis , position  } = this.options;\n        return position === 'top' || position === 'bottom' || axis === 'x';\n    }\n isFullSize() {\n        return this.options.fullSize;\n    }\n _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if (isNullOrUndef(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n        }\n        return labelSizes;\n    }\n _computeLabelSizes(ticks, length, maxTicksLimit) {\n        const { ctx , _longestTextCache: caches  } = this;\n        const widths = [];\n        const heights = [];\n        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; i += increment){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!isNullOrUndef(label) && !isArray(label)) {\n                width = _measureText(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if (isArray(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel =  label[j];\n                    if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n                        width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n getLabelForValue(value) {\n        return value;\n    }\n getPixelForValue(value, index) {\n        return NaN;\n    }\n getValueForPixel(pixel) {}\n getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n    }\n getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n getBaseValue() {\n        const { min , max  } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = toRadians(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n _isVisible() {\n        const display = this.options.display;\n        if (display !== 'auto') {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid , position , border  } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return _alignPixel(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === 'top') {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === 'bottom') {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === 'left') {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === 'right') {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const context = this.getContext(i);\n            const optsAtIndex = grid.setContext(context);\n            const optsAtIndexBorder = border.setContext(context);\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndexBorder.dash || [];\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position , ticks: optionTicks  } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align , crossAlign , padding , mirror  } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -toRadians(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = 'middle';\n        if (position === 'top') {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'bottom') {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'left') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === 'right') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === 'y') {\n            if (align === 'start') {\n                textBaseline = 'top';\n            } else if (align === 'end') {\n                textBaseline = 'bottom';\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = isArray(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === 'inner') {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? 'right' : 'left';\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? 'left' : 'right';\n                    } else {\n                        tickTextAlign = 'center';\n                    }\n                }\n                if (position === 'top') {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n                    x += lineHeight / 2 * Math.sin(rotation);\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = toPadding(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = textOffset - labelPadding.top;\n                let left = 0 - labelPadding.left;\n                switch(textBaseline){\n                    case 'middle':\n                        top -= height / 2;\n                        break;\n                    case 'bottom':\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case 'center':\n                        left -= width / 2;\n                        break;\n                    case 'right':\n                        left -= width;\n                        break;\n                    case 'inner':\n                        if (i === ilen - 1) {\n                            left -= width;\n                        } else if (i > 0) {\n                            left -= width / 2;\n                        }\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                label,\n                font,\n                textOffset,\n                options: {\n                    rotation,\n                    color,\n                    strokeColor,\n                    strokeWidth,\n                    textAlign: tickTextAlign,\n                    textBaseline,\n                    translation: [\n                        x,\n                        y\n                    ],\n                    backdrop\n                }\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position , ticks  } = this.options;\n        const rotation = -toRadians(this.labelRotation);\n        if (rotation) {\n            return position === 'top' ? 'left' : 'right';\n        }\n        let align = 'center';\n        if (ticks.align === 'start') {\n            align = 'left';\n        } else if (ticks.align === 'end') {\n            align = 'right';\n        } else if (ticks.align === 'inner') {\n            align = 'inner';\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === 'left') {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x = this.left;\n                }\n            }\n        } else if (position === 'right') {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = 'right';\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === 'left' || position === 'right') {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === 'top' || position === 'bottom') {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n drawBackground() {\n        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n drawBorder() {\n        const { chart , ctx , options: { border , grid  }  } = this;\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = border.display ? borderOpts.width : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.width;\n        ctx.strokeStyle = borderOpts.color;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            clipArea(ctx, area);\n        }\n        const items = this.getLabelItems(chartArea);\n        for (const item of items){\n            const renderTextOptions = item.options;\n            const tickFont = item.font;\n            const label = item.label;\n            const y = item.textOffset;\n            renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n        }\n        if (area) {\n            unclipArea(ctx);\n        }\n    }\n drawTitle() {\n        const { ctx , options: { position , title , reverse  }  } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = toFont(title.font);\n        const padding = toPadding(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === 'bottom' || position === 'center' || isObject(position)) {\n            offset += padding.bottom;\n            if (isArray(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);\n        renderText(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n        const bz = valueOrDefault(opts.border && opts.border.z, 0);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: bz,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + 'AxisID';\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return toFont(opts.font);\n    }\n _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\n\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + '.' + id;\n        if (!id) {\n            throw new Error('class does not have id: ' + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            defaults.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n get(id) {\n        return this.items[id];\n    }\n unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in defaults[scope]) {\n            delete defaults[scope][id];\n            if (this.override) {\n                delete overrides[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = merge(Object.create(null), [\n        parentScope ? defaults.get(parentScope) : {},\n        defaults.get(scope),\n        item.defaults\n    ]);\n    defaults.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        defaults.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split('.');\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join('.');\n        const parts = routes[property].split('.');\n        const targetName = parts.pop();\n        const targetScope = parts.join('.');\n        defaults.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n        this.elements = new TypedRegistry(Element, 'elements');\n        this.plugins = new TypedRegistry(Object, 'plugins');\n        this.scales = new TypedRegistry(Scale, 'scales');\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n add(...args) {\n        this._each('register', args);\n    }\n    remove(...args) {\n        this._each('unregister', args);\n    }\n addControllers(...args) {\n        this._each('register', args, this.controllers);\n    }\n addElements(...args) {\n        this._each('register', args, this.elements);\n    }\n addPlugins(...args) {\n        this._each('register', args, this.plugins);\n    }\n addScales(...args) {\n        this._each('register', args, this.scales);\n    }\n getController(id) {\n        return this._get(id, this.controllers, 'controller');\n    }\n getElement(id) {\n        return this._get(id, this.elements, 'element');\n    }\n getPlugin(id) {\n        return this._get(id, this.plugins, 'plugin');\n    }\n getScale(id) {\n        return this._get(id, this.scales, 'scale');\n    }\n removeControllers(...args) {\n        this._each('unregister', args, this.controllers);\n    }\n removeElements(...args) {\n        this._each('unregister', args, this.elements);\n    }\n removePlugins(...args) {\n        this._each('unregister', args, this.plugins);\n    }\n removeScales(...args) {\n        this._each('unregister', args, this.scales);\n    }\n _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                each(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n _exec(method, registry, component) {\n        const camelMethod = _capitalize(method);\n        callback(component['before' + camelMethod], [], component);\n        registry[method](component);\n        callback(component['after' + camelMethod], [], component);\n    }\n _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n        }\n        return item;\n    }\n}\nvar registry = /* #__PURE__ */ new Registry();\n\nclass PluginService {\n    constructor(){\n        this._init = [];\n    }\n notify(chart, hook, args, filter) {\n        if (hook === 'beforeInit') {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, 'install');\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === 'afterDestroy') {\n            this._notify(descriptors, chart, 'stop');\n            this._notify(this._init, chart, 'uninstall');\n        }\n        return result;\n    }\n _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if (callback(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!isNullOrUndef(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = valueOrDefault(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n        this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n    }\n}\n function allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins , localIds  }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin , local  }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        ''\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\n\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = defaults.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === '_index_') {\n        axis = indexAxis;\n    } else if (id === '_value_') {\n        axis = indexAxis === 'x' ? 'y' : 'x';\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction idMatchesAxis(id) {\n    if (id === 'x' || id === 'y' || id === 'r') {\n        return id;\n    }\n}\nfunction axisFromPosition(position) {\n    if (position === 'top' || position === 'bottom') {\n        return 'x';\n    }\n    if (position === 'left' || position === 'right') {\n        return 'y';\n    }\n}\nfunction determineAxis(id, ...scaleOptions) {\n    if (idMatchesAxis(id)) {\n        return id;\n    }\n    for (const opts of scaleOptions){\n        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n        if (axis) {\n            return axis;\n        }\n    }\n    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction getAxisFromDataset(id, axis, dataset) {\n    if (dataset[axis + 'AxisID'] === id) {\n        return {\n            axis\n        };\n    }\n}\nfunction retrieveAxisFromDatasets(id, config) {\n    if (config.data && config.data.datasets) {\n        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);\n        if (boundDs.length) {\n            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n        }\n    }\n    return {};\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = overrides[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!isObject(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        scales[id] = mergeIf(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = overrides[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + 'AxisID'] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            mergeIf(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        mergeIf(scale, [\n            defaults.scales[scale.type],\n            defaults.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = valueOrDefault(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = resolveObjectKey(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    ''\n                ]\n            ]);\n    }\n pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options , type  } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, defaults, key));\n            keys.forEach((key)=>addIfFound(scopes, descriptors, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n chartOptionScopes() {\n        const { options , type  } = this;\n        return [\n            options,\n            overrides[type] || {},\n            defaults.datasets[type] || {},\n            {\n                type\n            },\n            defaults,\n            descriptors\n        ];\n    }\n resolveNamedOptions(scopes, names, context, prefixes = [\n        ''\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = isFunction(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = _attachContext(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n createResolver(scopes, context, prefixes = [\n        ''\n    ], descriptorDefaults) {\n        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);\n        return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = _createResolver(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>isObject(value) && Object.getOwnPropertyNames(value).some((key)=>isFunction(value[key]));\nfunction needContext(proxy, names) {\n    const { isScriptable , isIndexable  } = _descriptors(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar version = \"4.5.0\";\n\nconst KNOWN_POSITIONS = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n    'chartArea'\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins('afterRender');\n    callback(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    callback(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\n function getCanvas(item) {\n    if (_isDomSupported() && typeof item === 'string') {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\n function determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === 'mouseout') {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nclass Chart {\n    static defaults = defaults;\n    static instances = instances;\n    static overrides = overrides;\n    static registry = registry;\n    static version = version;\n    static getChart = getChart;\n    static register(...items) {\n        registry.add(...items);\n        invalidatePlugins();\n    }\n    static unregister(...items) {\n        registry.remove(...items);\n        invalidatePlugins();\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.');\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = uid();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n         this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, 'complete', onAnimationsComplete);\n        animator.listen(this, 'progress', onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;\n        if (!isNullOrUndef(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    get registry() {\n        return registry;\n    }\n _initialize() {\n        this.notifyPlugins('beforeInit');\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            retinaScale(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins('afterInit');\n        return this;\n    }\n    clear() {\n        clearCanvas(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? 'resize' : 'attach';\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!retinaScale(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins('resize', {\n            size: newSize\n        });\n        callback(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        each(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === 'r';\n                const isHorizontal = axis === 'x';\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n                };\n            }));\n        }\n        each(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        each(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        each(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n    }\n _removeUnreferencedMetasets() {\n        const { _metasets: metasets , data: { datasets  }  } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = '' + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType , dataElementType  } = defaults.datasets[type];\n                Object.assign(ControllerClass, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n _resetElements() {\n        each(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n reset() {\n        this._resetElements();\n        this.notifyPlugins('reset');\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins('beforeUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins('beforeElementsUpdate');\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller  } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            each(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins('afterUpdate', {\n            mode\n        });\n        this._layers.sort(compare2Level('z', '_idx'));\n        const { _active , _lastEvent  } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n _updateScales() {\n        each(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n _updateHiddenIndices() {\n        const { _hiddenIndices  } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method , start , count  } of changes){\n            const move = method === '_removeElements' ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!setsEqual(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n _updateLayout(minPadding) {\n        if (this.notifyPlugins('beforeLayout', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        each(this.boxes, (box)=>{\n            if (noArea && box.position === 'chartArea') {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins('afterLayout');\n    }\n _updateDatasets(mode) {\n        if (this.notifyPlugins('beforeDatasetsUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, isFunction(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins('afterDatasetsUpdate', {\n            mode\n        });\n    }\n _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetUpdate', args);\n    }\n    render() {\n        if (this.notifyPlugins('beforeRender', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width , height  } = this._resizeBeforeDraw;\n            this._resizeBeforeDraw = null;\n            this._resize(width, height);\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins('beforeDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins('afterDraw');\n    }\n _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n _drawDatasets() {\n        if (this.notifyPlugins('beforeDatasetsDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins('afterDatasetsDraw');\n    }\n _drawDataset(meta) {\n        const ctx = this.ctx;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        const clip = getDatasetClipArea(this, meta);\n        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n            return;\n        }\n        if (clip) {\n            clipArea(ctx, clip);\n        }\n        meta.controller.draw();\n        if (clip) {\n            unclipArea(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetDraw', args);\n    }\n isPointInArea(point) {\n        return _isPointInArea(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === 'function') {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = createContext(null, {\n            chart: this,\n            type: 'chart'\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? 'show' : 'hide';\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if (defined(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins('beforeDestroy');\n        const { canvas , ctx  } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            clearCanvas(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        delete instances[this.id];\n        this.notifyPlugins('afterDestroy');\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        each(this.options.events, (type)=>_add(type, listener));\n    }\n bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove('attach', attached);\n            this.attached = true;\n            this.resize();\n            _add('resize', listener);\n            _add('detach', detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove('resize', listener);\n            this._stop();\n            this._resize(0, 0);\n            _add('attach', attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n unbindEvents() {\n        each(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        each(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? 'set' : 'remove';\n        let meta, item, i, ilen;\n        if (mode === 'dataset') {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller['_' + prefix + 'DatasetHoverStyle']();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('No dataset found at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n isPluginEnabled(pluginId) {\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\n    }\n _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins('afterEvent', args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [] , options  } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = _isClickEvent(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            callback(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                callback(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nfunction invalidatePlugins() {\n    return each(Chart.instances, (chart)=>chart._plugins.invalidate());\n}\n\nfunction clipSelf(ctx, element, endAngle) {\n    const { startAngle , x , y , outerRadius , innerRadius , options  } = element;\n    const { borderWidth , borderJoinStyle  } = options;\n    const outerAngleClip = Math.min(borderWidth / outerRadius, _normalizeAngle(startAngle - endAngle));\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius - borderWidth / 2, startAngle + outerAngleClip / 2, endAngle - outerAngleClip / 2);\n    if (innerRadius > 0) {\n        const innerAngleClip = Math.min(borderWidth / innerRadius, _normalizeAngle(startAngle - endAngle));\n        ctx.arc(x, y, innerRadius + borderWidth / 2, endAngle - innerAngleClip / 2, startAngle + innerAngleClip / 2, true);\n    } else {\n        const clipWidth = Math.min(borderWidth / 2, outerRadius * _normalizeAngle(startAngle - endAngle));\n        if (borderJoinStyle === 'round') {\n            ctx.arc(x, y, clipWidth, endAngle - PI / 2, startAngle + PI / 2, true);\n        } else if (borderJoinStyle === 'bevel') {\n            const r = 2 * clipWidth * clipWidth;\n            const endX = -r * Math.cos(endAngle + PI / 2) + x;\n            const endY = -r * Math.sin(endAngle + PI / 2) + y;\n            const startX = r * Math.cos(startAngle + PI / 2) + x;\n            const startY = r * Math.sin(startAngle + PI / 2) + y;\n            ctx.lineTo(endX, endY);\n            ctx.lineTo(startX, startY);\n        }\n    }\n    ctx.closePath();\n    ctx.moveTo(0, 0);\n    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.clip('evenodd');\n}\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    // Draw an inner border by clipping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return _readValueToProps(value, [\n        'outerStart',\n        'outerEnd',\n        'innerStart',\n        'innerEnd'\n    ]);\n}\n/**\n * Parse border radius from the provided options\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    // Outer limits are complicated. We want to compute the available angular distance at\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n    //\n    // If the borderRadius is large, that value can become negative.\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n    // we know that the thickness term will dominate and compute the limits at that point\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: _limitValue(o.innerStart, 0, innerLimit),\n        innerEnd: _limitValue(o.innerEnd, 0, innerLimit)\n    };\n}\n/**\n * Convert (r, 𝜃) to (x, y)\n */ function rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        // When spacing is present, it is the same for all items\n        // So we adjust the start and end angle of the arc such that\n        // the distance is the same as it would be without the spacing\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        // The first arc segments from point 1 to point a to point 2\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n        // The corner segment from point 2 to point 3\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n        }\n        // The line from point 3 to point 4\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        // The corner segment from point 4 to point 5\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n        }\n        // The inner arc from point 5 to point b to point 6\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n        // The corner segment from point 6 to point 7\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n        }\n        // The line from point 7 to point 8\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        // The corner segment from point 8 to point 1\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference  } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference , options  } = element;\n    const { borderWidth , borderJoinStyle , borderDash , borderDashOffset , borderRadius  } = options;\n    const inner = options.borderAlign === 'inner';\n    if (!borderWidth) {\n        return;\n    }\n    ctx.setLineDash(borderDash || []);\n    ctx.lineDashOffset = borderDashOffset;\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || 'round';\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || 'bevel';\n    }\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.stroke();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    if (options.selfJoin && endAngle - startAngle >= PI && borderRadius === 0 && borderJoinStyle !== 'miter') {\n        clipSelf(ctx, element, endAngle);\n    }\n    if (!fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        ctx.stroke();\n    }\n}\nclass ArcElement extends Element {\n    static id = 'arc';\n    static defaults = {\n        borderAlign: 'center',\n        borderColor: '#fff',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: undefined,\n        borderRadius: 0,\n        borderWidth: 2,\n        offset: 0,\n        spacing: 0,\n        angle: undefined,\n        circular: true,\n        selfJoin: false\n    };\n    static defaultRoutes = {\n        backgroundColor: 'backgroundColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash'\n    };\n    circumference;\n    endAngle;\n    fullCircles;\n    innerRadius;\n    outerRadius;\n    pixelMargin;\n    startAngle;\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        const { angle , distance  } = getAngleFromPoint(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius',\n            'circumference'\n        ], useFinalPosition);\n        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n        const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n        const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n        const betweenAngles = _circumference >= TAU || nonZeroBetween;\n        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([\n            'x',\n            'y',\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius'\n        ], useFinalPosition);\n        const { offset , spacing  } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options , circumference  } = this;\n        const offset = (options.offset || 0) / 4;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\n        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n        const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n        const radiusOffset = offset * fix;\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\n        ctx.restore();\n    }\n}\n\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\n function getLineMethod(options) {\n    if (options.stepped) {\n        return _steppedLineTo;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierCurveTo;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;\n    const { start: segmentStart , end: segmentEnd  } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\n function pathSegment(ctx, line, segment, params) {\n    const { points , options  } = line;\n    const { count , start , loop , ilen  } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move =true , reverse  } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\n function fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count , start , ilen  } = pathVars(points, segment, params);\n    const { move =true , reverse  } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\n function _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\n function _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _steppedInterpolation;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierInterpolation;\n    }\n    return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments , options  } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    static id = 'line';\n static defaults = {\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: 'miter',\n        borderWidth: 3,\n        capBezierPoints: true,\n        cubicInterpolationMode: 'default',\n        fill: false,\n        spanGaps: false,\n        stepped: false,\n        tension: 0\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'\n    };\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n    }\n first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = _boundSegments(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start , end  } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value  } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    static id = 'point';\n    parsed;\n    skip;\n    stop;\n    /**\n   * @type {any}\n   */ static defaults = {\n        borderWidth: 1,\n        hitRadius: 1,\n        hoverBorderWidth: 1,\n        hoverRadius: 4,\n        pointStyle: 'circle',\n        radius: 3,\n        rotation: 0\n    };\n    /**\n   * @type {any}\n   */ static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, 'x', useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, 'y', useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        drawPoint(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        // @ts-expect-error Fallbacks should never be hit in practice\n        return options.radius + options.hitRadius;\n    }\n}\n\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x , y , base , width , height  } =  bar.getProps([\n        'x',\n        'y',\n        'base',\n        'width',\n        'height'\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = toTRBL(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius  } = bar.getProps([\n        'enableBorderRadius'\n    ]);\n    const value = bar.options.borderRadius;\n    const o = toTRBLCorners(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || isObject(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n function addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    static id = 'bar';\n static defaults = {\n        borderSkipped: 'start',\n        borderWidth: 0,\n        borderRadius: 0,\n        inflateAmount: 'auto',\n        pointStyle: undefined\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;\n        const { inner , outer  } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill('evenodd');\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , base , horizontal  } =  this.getProps([\n            'x',\n            'y',\n            'base',\n            'horizontal'\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === 'x' ? this.width / 2 : this.height / 2;\n    }\n}\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nBarElement: BarElement,\nLineElement: LineElement,\nPointElement: PointElement\n});\n\nconst BORDER_COLORS = [\n    'rgb(54, 162, 235)',\n    'rgb(255, 99, 132)',\n    'rgb(255, 159, 64)',\n    'rgb(255, 205, 86)',\n    'rgb(75, 192, 192)',\n    'rgb(153, 102, 255)',\n    'rgb(201, 203, 207)' // grey\n];\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\nfunction getBorderColor(i) {\n    return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n    dataset.borderColor = getBorderColor(i);\n    dataset.backgroundColor = getBackgroundColor(i);\n    return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\n    return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\n    return i;\n}\nfunction getColorizer(chart) {\n    let i = 0;\n    return (dataset, datasetIndex)=>{\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\n        if (controller instanceof DoughnutController) {\n            i = colorizeDoughnutDataset(dataset, i);\n        } else if (controller instanceof PolarAreaController) {\n            i = colorizePolarAreaDataset(dataset, i);\n        } else if (controller) {\n            i = colorizeDefaultDataset(dataset, i);\n        }\n    };\n}\nfunction containsColorsDefinitions(descriptors) {\n    let k;\n    for(k in descriptors){\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction containsColorsDefinition(descriptor) {\n    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\nfunction containsDefaultColorsDefenitions() {\n    return defaults.borderColor !== 'rgba(0,0,0,0.1)' || defaults.backgroundColor !== 'rgba(0,0,0,0.1)';\n}\nvar plugin_colors = {\n    id: 'colors',\n    defaults: {\n        enabled: true,\n        forceOverride: false\n    },\n    beforeLayout (chart, _args, options) {\n        if (!options.enabled) {\n            return;\n        }\n        const { data: { datasets  } , options: chartOptions  } = chart.config;\n        const { elements  } = chartOptions;\n        const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();\n        if (!options.forceOverride && containsColorDefenition) {\n            return;\n        }\n        const colorizer = getColorizer(chart);\n        datasets.forEach(colorizer);\n    }\n};\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx , y: pointAy  } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, 'data', {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale  } = meta;\n    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n    if (minDefined) {\n        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: 'decimation',\n    defaults: {\n        algorithm: 'min-max',\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data , indexAxis  } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if (resolve([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === 'y') {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if (isNullOrUndef(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, 'data', {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case 'lttb':\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case 'min-max':\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\n\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start , end  } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = _boundSegments(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = _boundSegment(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === 'angle') {\n        start = _normalizeAngle(start);\n        end = _normalizeAngle(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x =null , y =null  } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start , end  })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if (isArray(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!isNumberFinite(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\n function _decodeFill(line, index, count) {\n     const fill = parseFillOption(line);\n    if (isObject(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if (isNumberFinite(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        'origin',\n        'start',\n        'end',\n        'stack',\n        'shape'\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === '-' || firstCh === '+') {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\n function _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === 'start') {\n        pixel = scale.bottom;\n    } else if (fill === 'end') {\n        pixel = scale.top;\n    } else if (isObject(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\n function _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === 'start') {\n        value = startValue;\n    } else if (fill === 'end') {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if (isObject(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\n function parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return 'origin';\n    }\n    return fill;\n}\n\nfunction _buildStackLine(source) {\n    const { scale , index , line  } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\n function getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas('line');\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\n function addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first , last , point  } = findPoint(line, sourcePoint, 'x');\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\n function findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if (_isBetween(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\n\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x , y , radius  } = this;\n        bounds = bounds || {\n            start: 0,\n            end: TAU\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x , y , radius  } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\n\nfunction _getTarget(source) {\n    const { chart , fill , line  } = source;\n    if (isNumberFinite(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === 'stack') {\n        return _buildStackLine(source);\n    }\n    if (fill === 'shape') {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\n function getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale ={} , fill  } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if (isNumberFinite(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale , fill  } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { chart , index , line , scale , axis  } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above =color , below =color  } = fillOption || {};\n    const meta = chart.getDatasetMeta(index);\n    const clip = getDatasetClipArea(chart, meta);\n    if (target && line.points.length) {\n        clipArea(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis,\n            clip\n        });\n        unclipArea(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line , target , above , below , area , scale , clip  } = cfg;\n    const property = line._loop ? 'angle' : cfg.axis;\n    ctx.save();\n    let fillColor = below;\n    if (below !== above) {\n        if (property === 'x') {\n            clipVertical(ctx, target, area.top);\n            fill(ctx, {\n                line,\n                target,\n                color: above,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipVertical(ctx, target, area.bottom);\n        } else if (property === 'y') {\n            clipHorizontal(ctx, target, area.left);\n            fill(ctx, {\n                line,\n                target,\n                color: below,\n                scale,\n                property,\n                clip\n            });\n            ctx.restore();\n            ctx.save();\n            clipHorizontal(ctx, target, area.right);\n            fillColor = above;\n        }\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: fillColor,\n        scale,\n        property,\n        clip\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments , points  } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start , end  } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction clipHorizontal(ctx, target, clipX) {\n    const { segments , points  } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start , end  } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(clipX, firstPoint.y);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(clipX, lastPoint.y);\n        }\n    }\n    ctx.lineTo(clipX, target.first().y);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line , target , property , color , scale , clip  } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src , target: tgt , start , end  } of segments){\n        const { style: { backgroundColor =color  } = {}  } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, clip, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? 'evenodd' : 'nonzero');\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, clip, bounds) {\n    const chartArea = scale.chart.chartArea;\n    const { property , start , end  } = bounds || {};\n    if (property === 'x' || property === 'y') {\n        let left, top, right, bottom;\n        if (property === 'x') {\n            left = start;\n            top = chartArea.top;\n            right = end;\n            bottom = chartArea.bottom;\n        } else {\n            left = chartArea.left;\n            top = start;\n            right = chartArea.right;\n            bottom = end;\n        }\n        ctx.beginPath();\n        if (clip) {\n            left = Math.max(left, clip.left);\n            right = Math.min(right, clip.right);\n            top = Math.max(top, clip.top);\n            bottom = Math.min(bottom, clip.bottom);\n        }\n        ctx.rect(left, top, right - left, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\n\nvar index = {\n    id: 'filler',\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === 'beforeDraw';\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== 'beforeDatasetsDraw') {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: 'beforeDatasetDraw'\n    }\n};\n\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = callback(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options , ctx  } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = toFont(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;\n        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === 'top' || this.options.position === 'bottom';\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            clipArea(ctx, this);\n            this._draw();\n            unclipArea(ctx);\n        }\n    }\n _draw() {\n        const { options: opts , columnSizes , lineWidths , ctx  } = this;\n        const { align , labels: labelOpts  } = opts;\n        const defaultColor = defaults.color;\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const labelFont = toFont(labelOpts.font);\n        const { padding  } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign('left');\n        ctx.textBaseline = 'middle';\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = toTRBLCorners(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    addRoundedRectPath(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        overrideTextDirection(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor;\n            ctx.fillStyle = legendItem.fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else if (typeof legendItem.text !== 'string') {\n                const fontLineHeight = labelFont.lineHeight;\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        restoreTextDirection(this.ctx, opts.textDirection);\n    }\n drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = _alignStartEnd(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n        ctx.textBaseline = 'middle';\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        renderText(ctx, titleOpts.text, x, y, titleFont);\n    }\n _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === 'mousemove' || e.type === 'mouseout') {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                callback(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                callback(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            callback(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n    return {\n        itemWidth,\n        itemHeight\n    };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n    let legendItemText = legendItem.text;\n    if (legendItemText && typeof legendItemText !== 'string') {\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\n    }\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n    let itemHeight = _itemHeight;\n    if (typeof legendItem.text !== 'string') {\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n    }\n    return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n    const labelHeight = legendItem.text ? legendItem.text.length : 0;\n    return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: 'legend',\n _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: 'top',\n        align: 'center',\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = toPadding(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: 'center',\n            text: ''\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith('on'),\n        labels: {\n            _scriptable: (name)=>![\n                    'generateLabels',\n                    'filter',\n                    'sort'\n                ].includes(name)\n        }\n    }\n};\n\nclass Title extends Element {\n constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = isArray(opts.text) ? opts.text.length : 1;\n        this._padding = toPadding(opts.padding);\n        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === 'top' || pos === 'bottom';\n    }\n    _drawArgs(offset) {\n        const { top , left , bottom , right , options  } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = _alignStartEnd(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === 'left') {\n                titleX = left + offset;\n                titleY = _alignStartEnd(align, bottom, top);\n                rotation = PI * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = _alignStartEnd(align, top, bottom);\n                rotation = PI * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = toFont(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);\n        renderText(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: _toLeftRightCenter(opts.align),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: 'title',\n _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'bold'\n        },\n        fullSize: true,\n        padding: 10,\n        position: 'top',\n        text: '',\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: 'subtitle',\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'normal'\n        },\n        fullSize: true,\n        padding: 0,\n        position: 'top',\n        text: '',\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst positioners = {\n average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let xSet = new Set();\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                xSet.add(pos.x);\n                y += pos.y;\n                ++count;\n            }\n        }\n        if (count === 0 || xSet.size === 0) {\n            return false;\n        }\n        const xAverage = [\n            ...xSet\n        ].reduce((a, b)=>a + b) / xSet.size;\n        return {\n            x: xAverage,\n            y: y / count\n        };\n    },\n nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = distanceBetweenPoints(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if (isArray(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\n function splitNewlines(str) {\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n        return str.split('\\n');\n    }\n    return str;\n}\n function createTooltipItem(chart, item) {\n    const { element , datasetIndex , index  } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label , value  } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\n function getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body , footer , title  } = tooltip;\n    const { boxWidth , boxHeight  } = options;\n    const bodyFont = toFont(options.bodyFont);\n    const titleFont = toFont(options.titleFont);\n    const footerFont = toFont(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = toPadding(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    each(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    each(body, (bodyItem)=>{\n        each(bodyItem.before, maxLineWidth);\n        each(bodyItem.lines, maxLineWidth);\n        each(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    each(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y , height  } = size;\n    if (y < height / 2) {\n        return 'top';\n    } else if (y > chart.height - height / 2) {\n        return 'bottom';\n    }\n    return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x , width  } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === 'left' && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === 'right' && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x , width  } = size;\n    const { width: chartWidth , chartArea: { left , right  }  } = chart;\n    let xAlign = 'center';\n    if (yAlign === 'center') {\n        xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n    } else if (x <= width / 2) {\n        xAlign = 'left';\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = 'right';\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = 'center';\n    }\n    return xAlign;\n}\n function determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x , width  } = size;\n    if (xAlign === 'right') {\n        x -= width;\n    } else if (xAlign === 'center') {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y , height  } = size;\n    if (yAlign === 'top') {\n        y += paddingAndSize;\n    } else if (yAlign === 'bottom') {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\n function getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize , caretPadding , cornerRadius  } = options;\n    const { xAlign , yAlign  } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === 'center') {\n        if (xAlign === 'left') {\n            x += paddingAndSize;\n        } else if (xAlign === 'right') {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === 'left') {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === 'right') {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: _limitValue(x, 0, chart.width - size.width),\n        y: _limitValue(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = toPadding(options.padding);\n    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\n function getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return createContext(parent, {\n        tooltip,\n        tooltipItems,\n        type: 'tooltip'\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nconst defaultCallbacks = {\n    beforeTitle: noop,\n    title (tooltipItems) {\n        if (tooltipItems.length > 0) {\n            const item = tooltipItems[0];\n            const labels = item.chart.data.labels;\n            const labelCount = labels ? labels.length : 0;\n            if (this && this.options && this.options.mode === 'dataset') {\n                return item.dataset.label || '';\n            } else if (item.label) {\n                return item.label;\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                return labels[item.dataIndex];\n            }\n        }\n        return '';\n    },\n    afterTitle: noop,\n    beforeBody: noop,\n    beforeLabel: noop,\n    label (tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n            label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n            label += value;\n        }\n        return label;\n    },\n    labelColor (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            borderColor: options.borderColor,\n            backgroundColor: options.backgroundColor,\n            borderWidth: options.borderWidth,\n            borderDash: options.borderDash,\n            borderDashOffset: options.borderDashOffset,\n            borderRadius: 0\n        };\n    },\n    labelTextColor () {\n        return this.options.bodyColor;\n    },\n    labelPointStyle (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            pointStyle: options.pointStyle,\n            rotation: options.rotation\n        };\n    },\n    afterLabel: noop,\n    afterBody: noop,\n    beforeFooter: noop,\n    footer: noop,\n    afterFooter: noop\n};\n function invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n    const result = callbacks[name].call(ctx, arg);\n    if (typeof result === 'undefined') {\n        return defaultCallbacks[name].call(ctx, arg);\n    }\n    return result;\n}\nclass Tooltip extends Element {\n static positioners = positioners;\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks  } = options;\n        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks  } = options;\n        const bodyItems = [];\n        each(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks  } = options;\n        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        each(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign , yAlign  } = this;\n        const { caretSize , cornerRadius  } = options;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n        const { x: ptX , y: ptY  } = tooltipPoint;\n        const { width , height  } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === 'center') {\n            y2 = ptY + height / 2;\n            if (xAlign === 'left') {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === 'left') {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === 'right') {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === 'top') {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = 'middle';\n            titleFont = toFont(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColor = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight , boxWidth  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        const colorX = getAlignedX(this, 'left', options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.fillStyle = labelColor.backgroundColor;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.setLineDash(labelColor.borderDash || []);\n            ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n            const borderRadius = toTRBLCorners(labelColor.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                addRoundedRectPath(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.beginPath();\n                addRoundedRectPath(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body  } = this;\n        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = 'middle';\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        each(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            each(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            each(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        each(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = 'middle';\n            footerFont = toFont(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign , yAlign  } = this;\n        const { x , y  } = pt;\n        const { width , height  } = tooltipSize;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === 'top') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === 'center' && xAlign === 'right') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === 'bottom') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === 'center' && xAlign === 'left') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = toPadding(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            overrideTextDirection(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            restoreTextDirection(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('Cannot find a dataset at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n _positionChanged(active, e) {\n        const { caretX , caretY , options  } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nvar plugin_tooltip = {\n    id: 'tooltip',\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins('beforeTooltipDraw', {\n                ...args,\n                cancelable: true\n            }) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins('afterTooltipDraw', args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: 'average',\n        backgroundColor: 'rgba(0,0,0,0.8)',\n        titleColor: '#fff',\n        titleFont: {\n            weight: 'bold'\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: 'left',\n        bodyColor: '#fff',\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: 'left',\n        footerColor: '#fff',\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: 'bold'\n        },\n        footerAlign: 'left',\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: '#fff',\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: 'rgba(0,0,0,0)',\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: 'easeOutQuart'\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'width',\n                    'height',\n                    'caretX',\n                    'caretY'\n                ]\n            },\n            opacity: {\n                easing: 'linear',\n                duration: 200\n            }\n        },\n        callbacks: defaultCallbacks\n    },\n    defaultRoutes: {\n        bodyFont: 'font',\n        footerFont: 'font',\n        titleFont: 'font'\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: 'animation'\n        }\n    },\n    additionalOptionScopes: [\n        'interaction'\n    ]\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nColors: plugin_colors,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === 'string') {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);\nfunction _getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n        return labels[value];\n    }\n    return value;\n}\nclass CategoryScale extends Scale {\n    static id = 'category';\n static defaults = {\n        ticks: {\n            callback: _getLabelForValue\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index , label  } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this.getMinMax(true);\n        if (this.options.bounds === 'ticks') {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return _getLabelForValue.call(this, value);\n    }\n configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== 'number') {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\n\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin , max: rmax  } = dataRange;\n    const minDefined = !isNullOrUndef(min);\n    const maxDefined = !isNullOrUndef(max);\n    const countDefined = !isNullOrUndef(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!isNullOrUndef(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === 'ticks') {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));\n    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n        if (maxDefined && tickValue > max) {\n            break;\n        }\n        ticks.push({\n            value: tickValue\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {\n    const rad = toRadians(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * ('' + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n         this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero  } = this.options;\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = sign(min);\n            const maxSign = sign(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit , stepSize  } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\n\nclass LinearScale extends LinearScaleBase {\n    static id = 'linear';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.numeric\n        }\n    };\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? min : 0;\n        this.max = isNumberFinite(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = toRadians(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\n\nconst log10Floor = (v)=>Math.floor(log10(v));\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n    return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n    const rangeStep = Math.pow(10, rangeExp);\n    const start = Math.floor(min / rangeStep);\n    const end = Math.ceil(max / rangeStep);\n    return end - start;\n}\nfunction startExp(min, max) {\n    const range = max - min;\n    let rangeExp = log10Floor(range);\n    while(steps(min, max, rangeExp) > 10){\n        rangeExp++;\n    }\n    while(steps(min, max, rangeExp) < 10){\n        rangeExp--;\n    }\n    return Math.min(rangeExp, log10Floor(min));\n}\n function generateTicks(generationOptions, { min , max  }) {\n    min = finiteOrDefault(generationOptions.min, min);\n    const ticks = [];\n    const minExp = log10Floor(min);\n    let exp = startExp(min, max);\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    const stepSize = Math.pow(10, exp);\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\n    const start = Math.round((min - base) * precision) / precision;\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\n    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n    while(value < max){\n        ticks.push({\n            value,\n            major: isMajor(value),\n            significand\n        });\n        if (significand >= 10) {\n            significand = significand < 15 ? 15 : 20;\n        } else {\n            significand++;\n        }\n        if (significand >= 20) {\n            exp++;\n            significand = 2;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n    }\n    const lastTick = finiteOrDefault(generationOptions.max, value);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(lastTick),\n        significand\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    static id = 'logarithmic';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.logarithmic,\n            major: {\n                enabled: true\n            }\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return isNumberFinite(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n        this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(changeExponent(min, -1));\n                setMax(changeExponent(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(changeExponent(max, -1));\n        }\n        if (max <= 0) {\n            setMax(changeExponent(min, +1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n getLabelForValue(value) {\n        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = log10(start);\n        this._valueRange = log10(this.max) - log10(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\n\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = toPadding(tickOpts.backdropPadding);\n        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = isArray(label) ? label : [\n        label\n    ];\n    return {\n        w: _longestText(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\n function fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = toFont(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round(toDegrees(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction createPointLabelItem(scale, index, itemOpts) {\n    const outerDistance = scale.drawingArea;\n    const { extra , additionalAngle , padding , size  } = itemOpts;\n    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    return {\n        visible: true,\n        x: pointLabelPosition.x,\n        y,\n        textAlign,\n        left,\n        top: y,\n        right: left + size.w,\n        bottom: y + size.h\n    };\n}\nfunction isNotOverlapped(item, area) {\n    if (!area) {\n        return true;\n    }\n    const { left , top , right , bottom  } = item;\n    const apexesInArea = _isPointInArea({\n        x: left,\n        y: top\n    }, area) || _isPointInArea({\n        x: left,\n        y: bottom\n    }, area) || _isPointInArea({\n        x: right,\n        y: top\n    }, area) || _isPointInArea({\n        x: right,\n        y: bottom\n    }, area);\n    return !apexesInArea;\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const { centerPointLabels , display  } = opts.pointLabels;\n    const itemOpts = {\n        extra: getTickBackdropHeight(opts) / 2,\n        additionalAngle: centerPointLabels ? PI / valueCount : 0\n    };\n    let area;\n    for(let i = 0; i < valueCount; i++){\n        itemOpts.padding = padding[i];\n        itemOpts.size = labelSizes[i];\n        const item = createPointLabelItem(scale, i, itemOpts);\n        items.push(item);\n        if (display === 'auto') {\n            item.visible = isNotOverlapped(item, area);\n            if (item.visible) {\n                area = item;\n            }\n        }\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return 'center';\n    } else if (angle < 180) {\n        return 'left';\n    }\n    return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === 'right') {\n        x -= w;\n    } else if (align === 'center') {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabelBox(ctx, opts, item) {\n    const { left , top , right , bottom  } = item;\n    const { backdropColor  } = opts;\n    if (!isNullOrUndef(backdropColor)) {\n        const borderRadius = toTRBLCorners(opts.borderRadius);\n        const padding = toPadding(opts.backdropPadding);\n        ctx.fillStyle = backdropColor;\n        const backdropLeft = left - padding.left;\n        const backdropTop = top - padding.top;\n        const backdropWidth = right - left + padding.width;\n        const backdropHeight = bottom - top + padding.height;\n        if (Object.values(borderRadius).some((v)=>v !== 0)) {\n            ctx.beginPath();\n            addRoundedRectPath(ctx, {\n                x: backdropLeft,\n                y: backdropTop,\n                w: backdropWidth,\n                h: backdropHeight,\n                radius: borderRadius\n            });\n            ctx.fill();\n        } else {\n            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n        }\n    }\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx , options: { pointLabels  }  } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const item = scale._pointLabelItems[i];\n        if (!item.visible) {\n            continue;\n        }\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        drawPointLabelBox(ctx, optsAtIndex, item);\n        const plFont = toFont(optsAtIndex.font);\n        const { x , y , textAlign  } = item;\n        renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: 'middle'\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx  } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color , lineWidth  } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(borderOpts.dash || []);\n    ctx.lineDashOffset = borderOpts.dashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return createContext(parent, {\n        label,\n        index,\n        type: 'pointLabel'\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    static id = 'radialLinear';\n static defaults = {\n        display: true,\n        animate: true,\n        position: 'chartArea',\n        angleLines: {\n            display: true,\n            lineWidth: 1,\n            borderDash: [],\n            borderDashOffset: 0.0\n        },\n        grid: {\n            circular: false\n        },\n        startAngle: 0,\n        ticks: {\n            showLabelBackdrop: true,\n            callback: Ticks.formatters.numeric\n        },\n        pointLabels: {\n            backdropColor: undefined,\n            backdropPadding: 2,\n            display: true,\n            font: {\n                size: 10\n            },\n            callback (label) {\n                return label;\n            },\n            padding: 5,\n            centerPointLabels: false\n        }\n    };\n    static defaultRoutes = {\n        'angleLines.color': 'borderColor',\n        'pointLabels.color': 'color',\n        'ticks.color': 'color'\n    };\n    static descriptors = {\n        angleLines: {\n            _fallback: 'grid'\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.xCenter = undefined;\n         this.yCenter = undefined;\n         this.drawingArea = undefined;\n         this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(false);\n        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = callback(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : '';\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = TAU / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if (isNullOrUndef(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if (isNullOrUndef(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left , top , right , bottom  } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n drawBackground() {\n        const { backgroundColor , grid: { circular  }  } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines , grid , border  } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0 || index === 0 && this.min < 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const context = this.getContext(index);\n                    const optsAtIndex = grid.setContext(context);\n                    const optsAtIndexBorder = border.setContext(context);\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color , lineWidth  } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n drawBorder() {}\n drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && this.min >= 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = toFont(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = toPadding(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            renderText(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color,\n                strokeColor: optsAtIndex.textStrokeColor,\n                strokeWidth: optsAtIndex.textStrokeWidth\n            });\n        });\n        ctx.restore();\n    }\n drawTitle() {}\n}\n\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\n const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);\n function sorter(a, b) {\n    return a - b;\n}\n function parse(scale, input) {\n    if (isNullOrUndef(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser , round , isoWeekday  } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === 'function') {\n        value = parser(value);\n    }\n    if (!isNumberFinite(value)) {\n        value = typeof parser === 'string' ? adapter.parse(value, parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\n function determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\n function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n function determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\n function addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo , hi  } = _lookup(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\n function setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\n function ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n     const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    static id = 'time';\n static defaults = {\n bounds: 'data',\n        adapters: {},\n        time: {\n            parser: false,\n            unit: false,\n            round: false,\n            isoWeekday: false,\n            minUnit: 'millisecond',\n            displayFormats: {}\n        },\n        ticks: {\n source: 'auto',\n            callback: false,\n            major: {\n                enabled: false\n            }\n        }\n    };\n constructor(props){\n        super(props);\n         this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n         this._unit = 'day';\n         this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts = {}) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        mergeIf(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || 'day';\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === 'ticks' && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = _filterBetween(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n initOffsets(timestamps = []) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = _limitValue(start, 0, limit);\n        end = _limitValue(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n        const hasWeekday = isNumber(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, 'isoWeek', weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n        }\n        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === 'ticks' || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort(sorter).map((x)=>+x);\n    }\n getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n format(value, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const fmt = format || formats[unit];\n        return this._adapter.format(value, fmt);\n    }\n _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formatter = options.ticks.callback;\n        if (formatter) {\n            return callback(formatter, [\n                time,\n                index,\n                ticks\n            ], this);\n        }\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    }\n generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n normalize(values) {\n        return _arrayUnique(values.sort(sorter));\n    }\n}\n\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo , hi  } = _lookupByKey(table, 'pos', val));\n        }\n        ({ pos: prevSource , time: prevTarget  } = table[lo]);\n        ({ pos: nextSource , time: nextTarget  } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo , hi  } = _lookupByKey(table, 'time', val));\n        }\n        ({ time: prevSource , pos: prevTarget  } = table[lo]);\n        ({ time: nextSource , pos: nextTarget  } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    static id = 'timeseries';\n static defaults = TimeScale.defaults;\n constructor(props){\n        super(props);\n         this._table = [];\n         this._minPos = undefined;\n         this._tableRange = undefined;\n    }\n initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n buildLookupTable(timestamps) {\n        const { min , max  } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n _generate() {\n        const min = this.min;\n        const max = this.max;\n        let timestamps = super.getDataTimestamps();\n        if (!timestamps.includes(min) || !timestamps.length) {\n            timestamps.splice(0, 0, min);\n        }\n        if (!timestamps.includes(max) || timestamps.length === 1) {\n            timestamps.push(max);\n        }\n        return timestamps.sort((a, b)=>a - b);\n    }\n _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n\nexport { Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, plugin_colors as Colors, DatasetController, plugin_decimation as Decimation, DomPlatform, DoughnutController, Element, index as Filler, Interaction, plugin_legend as Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, plugin_subtitle as SubTitle, Ticks, TimeScale, TimeSeriesScale, plugin_title as Title, plugin_tooltip as Tooltip, adapters as _adapters, _detectPlatform, animator, controllers, defaults, elements, layouts, plugins, registerables, registry, scales };\n//# sourceMappingURL=chart.js.map\n","import React, { forwardRef, useRef, useEffect } from 'react';\nimport { Chart as Chart$1, LineController, BarController, RadarController, DoughnutController, PolarAreaController, BubbleController, PieController, ScatterController } from 'chart.js';\n\nconst defaultDatasetIdKey = 'label';\nfunction reforwardRef(ref, value) {\n    if (typeof ref === 'function') {\n        ref(value);\n    } else if (ref) {\n        ref.current = value;\n    }\n}\nfunction setOptions(chart, nextOptions) {\n    const options = chart.options;\n    if (options && nextOptions) {\n        Object.assign(options, nextOptions);\n    }\n}\nfunction setLabels(currentData, nextLabels) {\n    currentData.labels = nextLabels;\n}\nfunction setDatasets(currentData, nextDatasets) {\n    let datasetIdKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultDatasetIdKey;\n    const addedDatasets = [];\n    currentData.datasets = nextDatasets.map((nextDataset)=>{\n        // given the new set, find it's current match\n        const currentDataset = currentData.datasets.find((dataset)=>dataset[datasetIdKey] === nextDataset[datasetIdKey]);\n        // There is no original to update, so simply add new one\n        if (!currentDataset || !nextDataset.data || addedDatasets.includes(currentDataset)) {\n            return {\n                ...nextDataset\n            };\n        }\n        addedDatasets.push(currentDataset);\n        Object.assign(currentDataset, nextDataset);\n        return currentDataset;\n    });\n}\nfunction cloneData(data) {\n    let datasetIdKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultDatasetIdKey;\n    const nextData = {\n        labels: [],\n        datasets: []\n    };\n    setLabels(nextData, data.labels);\n    setDatasets(nextData, data.datasets, datasetIdKey);\n    return nextData;\n}\n/**\n * Get dataset from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */ function getDatasetAtEvent(chart, event) {\n    return chart.getElementsAtEventForMode(event.nativeEvent, 'dataset', {\n        intersect: true\n    }, false);\n}\n/**\n * Get single dataset element from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */ function getElementAtEvent(chart, event) {\n    return chart.getElementsAtEventForMode(event.nativeEvent, 'nearest', {\n        intersect: true\n    }, false);\n}\n/**\n * Get all dataset elements from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */ function getElementsAtEvent(chart, event) {\n    return chart.getElementsAtEventForMode(event.nativeEvent, 'index', {\n        intersect: true\n    }, false);\n}\n\nfunction ChartComponent(props, ref) {\n    const { height = 150, width = 300, redraw = false, datasetIdKey, type, data, options, plugins = [], fallbackContent, updateMode, ...canvasProps } = props;\n    const canvasRef = useRef(null);\n    const chartRef = useRef(null);\n    const renderChart = ()=>{\n        if (!canvasRef.current) return;\n        chartRef.current = new Chart$1(canvasRef.current, {\n            type,\n            data: cloneData(data, datasetIdKey),\n            options: options && {\n                ...options\n            },\n            plugins\n        });\n        reforwardRef(ref, chartRef.current);\n    };\n    const destroyChart = ()=>{\n        reforwardRef(ref, null);\n        if (chartRef.current) {\n            chartRef.current.destroy();\n            chartRef.current = null;\n        }\n    };\n    useEffect(()=>{\n        if (!redraw && chartRef.current && options) {\n            setOptions(chartRef.current, options);\n        }\n    }, [\n        redraw,\n        options\n    ]);\n    useEffect(()=>{\n        if (!redraw && chartRef.current) {\n            setLabels(chartRef.current.config.data, data.labels);\n        }\n    }, [\n        redraw,\n        data.labels\n    ]);\n    useEffect(()=>{\n        if (!redraw && chartRef.current && data.datasets) {\n            setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);\n        }\n    }, [\n        redraw,\n        data.datasets\n    ]);\n    useEffect(()=>{\n        if (!chartRef.current) return;\n        if (redraw) {\n            destroyChart();\n            setTimeout(renderChart);\n        } else {\n            chartRef.current.update(updateMode);\n        }\n    }, [\n        redraw,\n        options,\n        data.labels,\n        data.datasets,\n        updateMode\n    ]);\n    useEffect(()=>{\n        if (!chartRef.current) return;\n        destroyChart();\n        setTimeout(renderChart);\n    }, [\n        type\n    ]);\n    useEffect(()=>{\n        renderChart();\n        return ()=>destroyChart();\n    }, []);\n    return /*#__PURE__*/ React.createElement(\"canvas\", {\n        ref: canvasRef,\n        role: \"img\",\n        height: height,\n        width: width,\n        ...canvasProps\n    }, fallbackContent);\n}\nconst Chart = /*#__PURE__*/ forwardRef(ChartComponent);\n\nfunction createTypedChart(type, registerables) {\n    Chart$1.register(registerables);\n    return /*#__PURE__*/ forwardRef((props, ref)=>/*#__PURE__*/ React.createElement(Chart, {\n            ...props,\n            ref: ref,\n            type: type\n        }));\n}\nconst Line = /* #__PURE__ */ createTypedChart('line', LineController);\nconst Bar = /* #__PURE__ */ createTypedChart('bar', BarController);\nconst Radar = /* #__PURE__ */ createTypedChart('radar', RadarController);\nconst Doughnut = /* #__PURE__ */ createTypedChart('doughnut', DoughnutController);\nconst PolarArea = /* #__PURE__ */ createTypedChart('polarArea', PolarAreaController);\nconst Bubble = /* #__PURE__ */ createTypedChart('bubble', BubbleController);\nconst Pie = /* #__PURE__ */ createTypedChart('pie', PieController);\nconst Scatter = /* #__PURE__ */ createTypedChart('scatter', ScatterController);\n\nexport { Bar, Bubble, Chart, Doughnut, Line, Pie, PolarArea, Radar, Scatter, getDatasetAtEvent, getElementAtEvent, getElementsAtEvent };\n//# sourceMappingURL=index.js.map\n","\"use client\"\n\nimport { Chart as ChartJS, ArcElement, Tooltip, Legend } from \"chart.js\";\nimport { Doughnut } from \"react-chartjs-2\";\n\nChartJS.register(ArcElement, Tooltip, Legend);\n\n\n\nconst DoughnutChart = ({ accounts }: DoughnutChartProps) => {\n  const accountNames = accounts.map((a) => a.name);\n  const balances = accounts.map((a) => a.currentBalance)\n\n  const data = {\n    datasets: [\n      {\n        label: 'Banks',\n        data: balances,\n        backgroundColor: ['#0747b6', '#2265d8', '#2f91fa'] \n      }\n    ],\n    labels: accountNames\n  }\n\n  return <Doughnut \n    data={data} \n    options={{\n      cutout: '60%',\n      plugins: {\n        legend: {\n          display: false\n        }\n      }\n    }}\n  />\n}\n\nexport default DoughnutChart","\"use client\";\n\nimport Image from \"next/image\";\nimport { useRouter, useSearchParams } from \"next/navigation\";\n\nimport { Button } from \"@/components/ui/button\";\nimport { formUrlQuery } from \"@/lib/utils\";\n\nexport const Pagination = ({ page, totalPages }: PaginationProps) => {\n  const router = useRouter();\n  const searchParams = useSearchParams()!;\n\n  const handleNavigation = (type: \"prev\" | \"next\") => {\n    const pageNumber = type === \"prev\" ? page - 1 : page + 1;\n\n    const newUrl = formUrlQuery({\n      params: searchParams.toString(),\n      key: \"page\",\n      value: pageNumber.toString(),\n    });\n\n    router.push(newUrl, { scroll: false });\n  };\n\n  return (\n    <div className=\"flex justify-between gap-3\">\n      <Button\n        size=\"lg\"\n        variant=\"ghost\"\n        className=\"p-0 hover:bg-transparent\"\n        onClick={() => handleNavigation(\"prev\")}\n        disabled={Number(page) <= 1}\n      >\n        <Image\n          src=\"/icons/arrow-left.svg\"\n          alt=\"arrow\"\n          width={20}\n          height={20}\n          className=\"mr-2\"\n        />\n        Prev\n      </Button>\n      <p className=\"text-14 flex items-center px-2\">\n        {page} / {totalPages}\n      </p>\n      <Button\n        size=\"lg\"\n        variant=\"ghost\"\n        className=\"p-0 hover:bg-transparent\"\n        onClick={() => handleNavigation(\"next\")}\n        disabled={Number(page) >= totalPages}\n      >\n        Next\n        <Image\n          src=\"/icons/arrow-left.svg\"\n          alt=\"arrow\"\n          width={20}\n          height={20}\n          className=\"ml-2 -scale-x-100\"\n        />\n      </Button>\n    </div>\n  );\n};\n","import * as React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Progress\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROGRESS_NAME = 'Progress';\nconst DEFAULT_MAX = 100;\n\ntype ScopedProps<P> = P & { __scopeProgress?: Scope };\nconst [createProgressContext, createProgressScope] = createContextScope(PROGRESS_NAME);\n\ntype ProgressState = 'indeterminate' | 'complete' | 'loading';\ntype ProgressContextValue = { value: number | null; max: number };\nconst [ProgressProvider, useProgressContext] =\n  createProgressContext<ProgressContextValue>(PROGRESS_NAME);\n\ntype ProgressElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ProgressProps extends PrimitiveDivProps {\n  value?: number | null | undefined;\n  max?: number;\n  getValueLabel?(value: number, max: number): string;\n}\n\nconst Progress = React.forwardRef<ProgressElement, ProgressProps>(\n  (props: ScopedProps<ProgressProps>, forwardedRef) => {\n    const {\n      __scopeProgress,\n      value: valueProp = null,\n      max: maxProp,\n      getValueLabel = defaultGetValueLabel,\n      ...progressProps\n    } = props;\n\n    if ((maxProp || maxProp === 0) && !isValidMaxNumber(maxProp)) {\n      console.error(getInvalidMaxError(`${maxProp}`, 'Progress'));\n    }\n\n    const max = isValidMaxNumber(maxProp) ? maxProp : DEFAULT_MAX;\n\n    if (valueProp !== null && !isValidValueNumber(valueProp, max)) {\n      console.error(getInvalidValueError(`${valueProp}`, 'Progress'));\n    }\n\n    const value = isValidValueNumber(valueProp, max) ? valueProp : null;\n    const valueLabel = isNumber(value) ? getValueLabel(value, max) : undefined;\n\n    return (\n      <ProgressProvider scope={__scopeProgress} value={value} max={max}>\n        <Primitive.div\n          aria-valuemax={max}\n          aria-valuemin={0}\n          aria-valuenow={isNumber(value) ? value : undefined}\n          aria-valuetext={valueLabel}\n          role=\"progressbar\"\n          data-state={getProgressState(value, max)}\n          data-value={value ?? undefined}\n          data-max={max}\n          {...progressProps}\n          ref={forwardedRef}\n        />\n      </ProgressProvider>\n    );\n  }\n);\n\nProgress.displayName = PROGRESS_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ProgressIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'ProgressIndicator';\n\ntype ProgressIndicatorElement = React.ComponentRef<typeof Primitive.div>;\ninterface ProgressIndicatorProps extends PrimitiveDivProps {}\n\nconst ProgressIndicator = React.forwardRef<ProgressIndicatorElement, ProgressIndicatorProps>(\n  (props: ScopedProps<ProgressIndicatorProps>, forwardedRef) => {\n    const { __scopeProgress, ...indicatorProps } = props;\n    const context = useProgressContext(INDICATOR_NAME, __scopeProgress);\n    return (\n      <Primitive.div\n        data-state={getProgressState(context.value, context.max)}\n        data-value={context.value ?? undefined}\n        data-max={context.max}\n        {...indicatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nProgressIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction defaultGetValueLabel(value: number, max: number) {\n  return `${Math.round((value / max) * 100)}%`;\n}\n\nfunction getProgressState(value: number | undefined | null, maxValue: number): ProgressState {\n  return value == null ? 'indeterminate' : value === maxValue ? 'complete' : 'loading';\n}\n\nfunction isNumber(value: any): value is number {\n  return typeof value === 'number';\n}\n\nfunction isValidMaxNumber(max: any): max is number {\n  // prettier-ignore\n  return (\n    isNumber(max) &&\n    !isNaN(max) &&\n    max > 0\n  );\n}\n\nfunction isValidValueNumber(value: any, max: number): value is number {\n  // prettier-ignore\n  return (\n    isNumber(value) &&\n    !isNaN(value) &&\n    value <= max &&\n    value >= 0\n  );\n}\n\n// Split this out for clearer readability of the error message.\nfunction getInvalidMaxError(propValue: string, componentName: string) {\n  return `Invalid prop \\`max\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. Only numbers greater than 0 are valid max values. Defaulting to \\`${DEFAULT_MAX}\\`.`;\n}\n\nfunction getInvalidValueError(propValue: string, componentName: string) {\n  return `Invalid prop \\`value\\` of value \\`${propValue}\\` supplied to \\`${componentName}\\`. The \\`value\\` prop must be:\n  - a positive number\n  - less than the value passed to \\`max\\` (or ${DEFAULT_MAX} if no \\`max\\` prop is set)\n  - \\`null\\` or \\`undefined\\` if the progress is indeterminate.\n\nDefaulting to \\`null\\`.`;\n}\n\nconst Root = Progress;\nconst Indicator = ProgressIndicator;\n\nexport {\n  createProgressScope,\n  //\n  Progress,\n  ProgressIndicator,\n  //\n  Root,\n  Indicator,\n};\nexport type { ProgressProps, ProgressIndicatorProps };\n","\"use client\"\n\nimport * as React from \"react\"\nimport * as ProgressPrimitive from \"@radix-ui/react-progress\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Progress = React.forwardRef<\n  React.ElementRef<typeof ProgressPrimitive.Root>,\n  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>\n>(({ indicatorClassName, className, value, ...props }, ref) => (\n  <ProgressPrimitive.Root\n    ref={ref}\n    className={cn(\n      \"relative h-4 w-full overflow-hidden rounded-full bg-secondary\",\n      className\n    )}\n    {...props}\n  >\n    <ProgressPrimitive.Indicator\n      className={cn('h-full w-full flex-1 bg-primary transition-all', indicatorClassName)}\n      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}\n    />\n  </ProgressPrimitive.Root>\n))\nProgress.displayName = ProgressPrimitive.Root.displayName\n\nexport { Progress }\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n  preventScrollOnEntryFocus?: boolean;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId ?? null,\n    onChange: onCurrentTabStopIdChange,\n    caller: GROUP_NAME,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes, preventScrollOnEntryFocus);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends Omit<PrimitiveSpanProps, 'children'> {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n  children?:\n    | React.ReactNode\n    | ((props: { hasTabStop: boolean; isCurrentTabStop: boolean }) => React.ReactNode);\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      children,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        >\n          {typeof children === 'function'\n            ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null })\n            : children}\n        </Primitive.span>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useId } from '@radix-ui/react-id';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Tabs\n * -----------------------------------------------------------------------------------------------*/\n\nconst TABS_NAME = 'Tabs';\n\ntype ScopedProps<P> = P & { __scopeTabs?: Scope };\nconst [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [\n  createRovingFocusGroupScope,\n]);\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype TabsContextValue = {\n  baseId: string;\n  value: string;\n  onValueChange: (value: string) => void;\n  orientation?: TabsProps['orientation'];\n  dir?: TabsProps['dir'];\n  activationMode?: TabsProps['activationMode'];\n};\n\nconst [TabsProvider, useTabsContext] = createTabsContext<TabsContextValue>(TABS_NAME);\n\ntype TabsElement = React.ComponentRef<typeof Primitive.div>;\ntype RovingFocusGroupProps = React.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface TabsProps extends PrimitiveDivProps {\n  /** The value for the selected tab, if controlled */\n  value?: string;\n  /** The value of the tab to select by default, if uncontrolled */\n  defaultValue?: string;\n  /** A function called when a new tab is selected */\n  onValueChange?: (value: string) => void;\n  /**\n   * The orientation the tabs are layed out.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   * @defaultValue horizontal\n   */\n  orientation?: RovingFocusGroupProps['orientation'];\n  /**\n   * The direction of navigation between toolbar items.\n   */\n  dir?: RovingFocusGroupProps['dir'];\n  /**\n   * Whether a tab is activated automatically or manually.\n   * @defaultValue automatic\n   * */\n  activationMode?: 'automatic' | 'manual';\n}\n\nconst Tabs = React.forwardRef<TabsElement, TabsProps>(\n  (props: ScopedProps<TabsProps>, forwardedRef) => {\n    const {\n      __scopeTabs,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      orientation = 'horizontal',\n      dir,\n      activationMode = 'automatic',\n      ...tabsProps\n    } = props;\n    const direction = useDirection(dir);\n    const [value, setValue] = useControllableState({\n      prop: valueProp,\n      onChange: onValueChange,\n      defaultProp: defaultValue ?? '',\n      caller: TABS_NAME,\n    });\n\n    return (\n      <TabsProvider\n        scope={__scopeTabs}\n        baseId={useId()}\n        value={value}\n        onValueChange={setValue}\n        orientation={orientation}\n        dir={direction}\n        activationMode={activationMode}\n      >\n        <Primitive.div\n          dir={direction}\n          data-orientation={orientation}\n          {...tabsProps}\n          ref={forwardedRef}\n        />\n      </TabsProvider>\n    );\n  }\n);\n\nTabs.displayName = TABS_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TabsList\n * -----------------------------------------------------------------------------------------------*/\n\nconst TAB_LIST_NAME = 'TabsList';\n\ntype TabsListElement = React.ComponentRef<typeof Primitive.div>;\ninterface TabsListProps extends PrimitiveDivProps {\n  loop?: RovingFocusGroupProps['loop'];\n}\n\nconst TabsList = React.forwardRef<TabsListElement, TabsListProps>(\n  (props: ScopedProps<TabsListProps>, forwardedRef) => {\n    const { __scopeTabs, loop = true, ...listProps } = props;\n    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n    return (\n      <RovingFocusGroup.Root\n        asChild\n        {...rovingFocusGroupScope}\n        orientation={context.orientation}\n        dir={context.dir}\n        loop={loop}\n      >\n        <Primitive.div\n          role=\"tablist\"\n          aria-orientation={context.orientation}\n          {...listProps}\n          ref={forwardedRef}\n        />\n      </RovingFocusGroup.Root>\n    );\n  }\n);\n\nTabsList.displayName = TAB_LIST_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TabsTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TabsTrigger';\n\ntype TabsTriggerElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface TabsTriggerProps extends PrimitiveButtonProps {\n  value: string;\n}\n\nconst TabsTrigger = React.forwardRef<TabsTriggerElement, TabsTriggerProps>(\n  (props: ScopedProps<TabsTriggerProps>, forwardedRef) => {\n    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;\n    const context = useTabsContext(TRIGGER_NAME, __scopeTabs);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);\n    const triggerId = makeTriggerId(context.baseId, value);\n    const contentId = makeContentId(context.baseId, value);\n    const isSelected = value === context.value;\n    return (\n      <RovingFocusGroup.Item\n        asChild\n        {...rovingFocusGroupScope}\n        focusable={!disabled}\n        active={isSelected}\n      >\n        <Primitive.button\n          type=\"button\"\n          role=\"tab\"\n          aria-selected={isSelected}\n          aria-controls={contentId}\n          data-state={isSelected ? 'active' : 'inactive'}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          id={triggerId}\n          {...triggerProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n            // but not when the control key is pressed (avoiding MacOS right click)\n            if (!disabled && event.button === 0 && event.ctrlKey === false) {\n              context.onValueChange(value);\n            } else {\n              // prevent focus to avoid accidental activation\n              event.preventDefault();\n            }\n          })}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if ([' ', 'Enter'].includes(event.key)) context.onValueChange(value);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => {\n            // handle \"automatic\" activation if necessary\n            // ie. activate tab following focus\n            const isAutomaticActivation = context.activationMode !== 'manual';\n            if (!isSelected && !disabled && isAutomaticActivation) {\n              context.onValueChange(value);\n            }\n          })}\n        />\n      </RovingFocusGroup.Item>\n    );\n  }\n);\n\nTabsTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TabsContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TabsContent';\n\ntype TabsContentElement = React.ComponentRef<typeof Primitive.div>;\ninterface TabsContentProps extends PrimitiveDivProps {\n  value: string;\n\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TabsContent = React.forwardRef<TabsContentElement, TabsContentProps>(\n  (props: ScopedProps<TabsContentProps>, forwardedRef) => {\n    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;\n    const context = useTabsContext(CONTENT_NAME, __scopeTabs);\n    const triggerId = makeTriggerId(context.baseId, value);\n    const contentId = makeContentId(context.baseId, value);\n    const isSelected = value === context.value;\n    const isMountAnimationPreventedRef = React.useRef(isSelected);\n\n    React.useEffect(() => {\n      const rAF = requestAnimationFrame(() => (isMountAnimationPreventedRef.current = false));\n      return () => cancelAnimationFrame(rAF);\n    }, []);\n\n    return (\n      <Presence present={forceMount || isSelected}>\n        {({ present }) => (\n          <Primitive.div\n            data-state={isSelected ? 'active' : 'inactive'}\n            data-orientation={context.orientation}\n            role=\"tabpanel\"\n            aria-labelledby={triggerId}\n            hidden={!present}\n            id={contentId}\n            tabIndex={0}\n            {...contentProps}\n            ref={forwardedRef}\n            style={{\n              ...props.style,\n              animationDuration: isMountAnimationPreventedRef.current ? '0s' : undefined,\n            }}\n          >\n            {present && children}\n          </Primitive.div>\n        )}\n      </Presence>\n    );\n  }\n);\n\nTabsContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction makeTriggerId(baseId: string, value: string) {\n  return `${baseId}-trigger-${value}`;\n}\n\nfunction makeContentId(baseId: string, value: string) {\n  return `${baseId}-content-${value}`;\n}\n\nconst Root = Tabs;\nconst List = TabsList;\nconst Trigger = TabsTrigger;\nconst Content = TabsContent;\n\nexport {\n  createTabsScope,\n  //\n  Tabs,\n  TabsList,\n  TabsTrigger,\n  TabsContent,\n  //\n  Root,\n  List,\n  Trigger,\n  Content,\n};\nexport type { TabsProps, TabsListProps, TabsTriggerProps, TabsContentProps };\n","\"use client\"\n\nimport * as React from \"react\"\nimport * as TabsPrimitive from \"@radix-ui/react-tabs\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst Tabs = TabsPrimitive.Root\n\nconst TabsList = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.List>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.List\n    ref={ref}\n    className={cn(\n      \"inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsList.displayName = TabsPrimitive.List.displayName\n\nconst TabsTrigger = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Trigger>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Trigger\n    ref={ref}\n    className={cn(\n      \"inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsTrigger.displayName = TabsPrimitive.Trigger.displayName\n\nconst TabsContent = React.forwardRef<\n  React.ElementRef<typeof TabsPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>\n>(({ className, ...props }, ref) => (\n  <TabsPrimitive.Content\n    ref={ref}\n    className={cn(\n      \"mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2\",\n      className\n    )}\n    {...props}\n  />\n))\nTabsContent.displayName = TabsPrimitive.Content.displayName\n\nexport { Tabs, TabsList, TabsTrigger, TabsContent }\n","!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?i(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],i):i((t=\"undefined\"!=typeof globalThis?globalThis:t||self).countUp={})}(this,(function(t){\"use strict\";var i=function(){return i=Object.assign||function(t){for(var i,n=1,s=arguments.length;n<s;n++)for(var e in i=arguments[n])Object.prototype.hasOwnProperty.call(i,e)&&(t[e]=i[e]);return t},i.apply(this,arguments)},n=function(){function t(t,n,s){var e=this;this.endVal=n,this.options=s,this.version=\"2.9.0\",this.defaults={startVal:0,decimalPlaces:0,duration:2,useEasing:!0,useGrouping:!0,useIndianSeparators:!1,smartEasingThreshold:999,smartEasingAmount:333,separator:\",\",decimal:\".\",prefix:\"\",suffix:\"\",enableScrollSpy:!1,scrollSpyDelay:200,scrollSpyOnce:!1},this.finalEndVal=null,this.useEasing=!0,this.countDown=!1,this.error=\"\",this.startVal=0,this.paused=!0,this.once=!1,this.count=function(t){e.startTime||(e.startTime=t);var i=t-e.startTime;e.remaining=e.duration-i,e.useEasing?e.countDown?e.frameVal=e.startVal-e.easingFn(i,0,e.startVal-e.endVal,e.duration):e.frameVal=e.easingFn(i,e.startVal,e.endVal-e.startVal,e.duration):e.frameVal=e.startVal+(e.endVal-e.startVal)*(i/e.duration);var n=e.countDown?e.frameVal<e.endVal:e.frameVal>e.endVal;e.frameVal=n?e.endVal:e.frameVal,e.frameVal=Number(e.frameVal.toFixed(e.options.decimalPlaces)),e.printValue(e.frameVal),i<e.duration?e.rAF=requestAnimationFrame(e.count):null!==e.finalEndVal?e.update(e.finalEndVal):e.options.onCompleteCallback&&e.options.onCompleteCallback()},this.formatNumber=function(t){var i,n,s,a,o=t<0?\"-\":\"\";i=Math.abs(t).toFixed(e.options.decimalPlaces);var r=(i+=\"\").split(\".\");if(n=r[0],s=r.length>1?e.options.decimal+r[1]:\"\",e.options.useGrouping){a=\"\";for(var l=3,u=0,h=0,p=n.length;h<p;++h)e.options.useIndianSeparators&&4===h&&(l=2,u=1),0!==h&&u%l==0&&(a=e.options.separator+a),u++,a=n[p-h-1]+a;n=a}return e.options.numerals&&e.options.numerals.length&&(n=n.replace(/[0-9]/g,(function(t){return e.options.numerals[+t]})),s=s.replace(/[0-9]/g,(function(t){return e.options.numerals[+t]}))),o+e.options.prefix+n+s+e.options.suffix},this.easeOutExpo=function(t,i,n,s){return n*(1-Math.pow(2,-10*t/s))*1024/1023+i},this.options=i(i({},this.defaults),s),this.formattingFn=this.options.formattingFn?this.options.formattingFn:this.formatNumber,this.easingFn=this.options.easingFn?this.options.easingFn:this.easeOutExpo,this.el=\"string\"==typeof t?document.getElementById(t):t,n=null==n?this.parse(this.el.innerHTML):n,this.startVal=this.validateValue(this.options.startVal),this.frameVal=this.startVal,this.endVal=this.validateValue(n),this.options.decimalPlaces=Math.max(this.options.decimalPlaces),this.resetDuration(),this.options.separator=String(this.options.separator),this.useEasing=this.options.useEasing,\"\"===this.options.separator&&(this.options.useGrouping=!1),this.el?this.printValue(this.startVal):this.error=\"[CountUp] target is null or undefined\",\"undefined\"!=typeof window&&this.options.enableScrollSpy&&(this.error?console.error(this.error,t):(window.onScrollFns=window.onScrollFns||[],window.onScrollFns.push((function(){return e.handleScroll(e)})),window.onscroll=function(){window.onScrollFns.forEach((function(t){return t()}))},this.handleScroll(this)))}return t.prototype.handleScroll=function(t){if(t&&window&&!t.once){var i=window.innerHeight+window.scrollY,n=t.el.getBoundingClientRect(),s=n.top+window.pageYOffset,e=n.top+n.height+window.pageYOffset;e<i&&e>window.scrollY&&t.paused?(t.paused=!1,setTimeout((function(){return t.start()}),t.options.scrollSpyDelay),t.options.scrollSpyOnce&&(t.once=!0)):(window.scrollY>e||s>i)&&!t.paused&&t.reset()}},t.prototype.determineDirectionAndSmartEasing=function(){var t=this.finalEndVal?this.finalEndVal:this.endVal;this.countDown=this.startVal>t;var i=t-this.startVal;if(Math.abs(i)>this.options.smartEasingThreshold&&this.options.useEasing){this.finalEndVal=t;var n=this.countDown?1:-1;this.endVal=t+n*this.options.smartEasingAmount,this.duration=this.duration/2}else this.endVal=t,this.finalEndVal=null;null!==this.finalEndVal?this.useEasing=!1:this.useEasing=this.options.useEasing},t.prototype.start=function(t){this.error||(this.options.onStartCallback&&this.options.onStartCallback(),t&&(this.options.onCompleteCallback=t),this.duration>0?(this.determineDirectionAndSmartEasing(),this.paused=!1,this.rAF=requestAnimationFrame(this.count)):this.printValue(this.endVal))},t.prototype.pauseResume=function(){this.paused?(this.startTime=null,this.duration=this.remaining,this.startVal=this.frameVal,this.determineDirectionAndSmartEasing(),this.rAF=requestAnimationFrame(this.count)):cancelAnimationFrame(this.rAF),this.paused=!this.paused},t.prototype.reset=function(){cancelAnimationFrame(this.rAF),this.paused=!0,this.resetDuration(),this.startVal=this.validateValue(this.options.startVal),this.frameVal=this.startVal,this.printValue(this.startVal)},t.prototype.update=function(t){cancelAnimationFrame(this.rAF),this.startTime=null,this.endVal=this.validateValue(t),this.endVal!==this.frameVal&&(this.startVal=this.frameVal,null==this.finalEndVal&&this.resetDuration(),this.finalEndVal=null,this.determineDirectionAndSmartEasing(),this.rAF=requestAnimationFrame(this.count))},t.prototype.printValue=function(t){var i;if(this.el){var n=this.formattingFn(t);if(null===(i=this.options.plugin)||void 0===i?void 0:i.render)this.options.plugin.render(this.el,n);else if(\"INPUT\"===this.el.tagName)this.el.value=n;else\"text\"===this.el.tagName||\"tspan\"===this.el.tagName?this.el.textContent=n:this.el.innerHTML=n}},t.prototype.ensureNumber=function(t){return\"number\"==typeof t&&!isNaN(t)},t.prototype.validateValue=function(t){var i=Number(t);return this.ensureNumber(i)?i:(this.error=\"[CountUp] invalid start or end value: \".concat(t),null)},t.prototype.resetDuration=function(){this.startTime=null,this.duration=1e3*Number(this.options.duration),this.remaining=this.duration},t.prototype.parse=function(t){var i=function(t){return t.replace(/([.,'  ])/g,\"\\\\$1\")},n=i(this.options.separator),s=i(this.options.decimal),e=t.replace(new RegExp(n,\"g\"),\"\").replace(new RegExp(s,\"g\"),\".\");return parseFloat(e)},t}();t.CountUp=n}));\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar React = require('react');\nvar countup_js = require('countup.js');\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\n * Silence SSR Warnings.\n * Borrowed from Formik v2.1.1, Licensed MIT.\n *\n * https://github.com/formium/formik/blob/9316a864478f8fcd4fa99a0735b1d37afdf507dc/LICENSE\n */\nvar useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/**\n * Create a stable reference to a callback which is updated after each render is committed.\n * Typed version borrowed from Formik v2.2.1. Licensed MIT.\n *\n * https://github.com/formium/formik/blob/9316a864478f8fcd4fa99a0735b1d37afdf507dc/LICENSE\n */\nfunction useEventCallback(fn) {\n  var ref = React.useRef(fn);\n\n  // we copy a ref to the callback scoped to the current state/props on each render\n  useIsomorphicLayoutEffect(function () {\n    ref.current = fn;\n  });\n  return React.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current.apply(void 0, args);\n  }, []);\n}\n\nvar createCountUpInstance = function createCountUpInstance(el, props) {\n  var decimal = props.decimal,\n    decimals = props.decimals,\n    duration = props.duration,\n    easingFn = props.easingFn,\n    end = props.end,\n    formattingFn = props.formattingFn,\n    numerals = props.numerals,\n    prefix = props.prefix,\n    separator = props.separator,\n    start = props.start,\n    suffix = props.suffix,\n    useEasing = props.useEasing,\n    useGrouping = props.useGrouping,\n    useIndianSeparators = props.useIndianSeparators,\n    enableScrollSpy = props.enableScrollSpy,\n    scrollSpyDelay = props.scrollSpyDelay,\n    scrollSpyOnce = props.scrollSpyOnce,\n    plugin = props.plugin;\n  return new countup_js.CountUp(el, end, {\n    startVal: start,\n    duration: duration,\n    decimal: decimal,\n    decimalPlaces: decimals,\n    easingFn: easingFn,\n    formattingFn: formattingFn,\n    numerals: numerals,\n    separator: separator,\n    prefix: prefix,\n    suffix: suffix,\n    plugin: plugin,\n    useEasing: useEasing,\n    useIndianSeparators: useIndianSeparators,\n    useGrouping: useGrouping,\n    enableScrollSpy: enableScrollSpy,\n    scrollSpyDelay: scrollSpyDelay,\n    scrollSpyOnce: scrollSpyOnce\n  });\n};\n\nvar _excluded$1 = [\"ref\", \"startOnMount\", \"enableReinitialize\", \"delay\", \"onEnd\", \"onStart\", \"onPauseResume\", \"onReset\", \"onUpdate\"];\nvar DEFAULTS = {\n  decimal: '.',\n  separator: ',',\n  delay: null,\n  prefix: '',\n  suffix: '',\n  duration: 2,\n  start: 0,\n  decimals: 0,\n  startOnMount: true,\n  enableReinitialize: true,\n  useEasing: true,\n  useGrouping: true,\n  useIndianSeparators: false\n};\nvar useCountUp = function useCountUp(props) {\n  var filteredProps = Object.fromEntries(Object.entries(props).filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      value = _ref2[1];\n    return value !== undefined;\n  }));\n  var _useMemo = React.useMemo(function () {\n      return _objectSpread2(_objectSpread2({}, DEFAULTS), filteredProps);\n    }, [props]),\n    ref = _useMemo.ref,\n    startOnMount = _useMemo.startOnMount,\n    enableReinitialize = _useMemo.enableReinitialize,\n    delay = _useMemo.delay,\n    onEnd = _useMemo.onEnd,\n    onStart = _useMemo.onStart,\n    onPauseResume = _useMemo.onPauseResume,\n    onReset = _useMemo.onReset,\n    onUpdate = _useMemo.onUpdate,\n    instanceProps = _objectWithoutProperties(_useMemo, _excluded$1);\n  var countUpRef = React.useRef();\n  var timerRef = React.useRef();\n  var isInitializedRef = React.useRef(false);\n  var createInstance = useEventCallback(function () {\n    return createCountUpInstance(typeof ref === 'string' ? ref : ref.current, instanceProps);\n  });\n  var getCountUp = useEventCallback(function (recreate) {\n    var countUp = countUpRef.current;\n    if (countUp && !recreate) {\n      return countUp;\n    }\n    var newCountUp = createInstance();\n    countUpRef.current = newCountUp;\n    return newCountUp;\n  });\n  var start = useEventCallback(function () {\n    var run = function run() {\n      return getCountUp(true).start(function () {\n        onEnd === null || onEnd === void 0 || onEnd({\n          pauseResume: pauseResume,\n          reset: reset,\n          start: restart,\n          update: update\n        });\n      });\n    };\n    if (delay && delay > 0) {\n      timerRef.current = setTimeout(run, delay * 1000);\n    } else {\n      run();\n    }\n    onStart === null || onStart === void 0 || onStart({\n      pauseResume: pauseResume,\n      reset: reset,\n      update: update\n    });\n  });\n  var pauseResume = useEventCallback(function () {\n    getCountUp().pauseResume();\n    onPauseResume === null || onPauseResume === void 0 || onPauseResume({\n      reset: reset,\n      start: restart,\n      update: update\n    });\n  });\n  var reset = useEventCallback(function () {\n    // Quick fix for https://github.com/glennreyes/react-countup/issues/736 - should be investigated\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (getCountUp().el) {\n      timerRef.current && clearTimeout(timerRef.current);\n      getCountUp().reset();\n      onReset === null || onReset === void 0 || onReset({\n        pauseResume: pauseResume,\n        start: restart,\n        update: update\n      });\n    }\n  });\n  var update = useEventCallback(function (newEnd) {\n    getCountUp().update(newEnd);\n    onUpdate === null || onUpdate === void 0 || onUpdate({\n      pauseResume: pauseResume,\n      reset: reset,\n      start: restart\n    });\n  });\n  var restart = useEventCallback(function () {\n    reset();\n    start();\n  });\n  var maybeInitialize = useEventCallback(function (shouldReset) {\n    if (startOnMount) {\n      if (shouldReset) {\n        reset();\n      }\n      start();\n    }\n  });\n  React.useEffect(function () {\n    if (!isInitializedRef.current) {\n      isInitializedRef.current = true;\n      maybeInitialize();\n    } else if (enableReinitialize) {\n      maybeInitialize(true);\n    }\n  }, [enableReinitialize, isInitializedRef, maybeInitialize, delay, props.start, props.suffix, props.prefix, props.duration, props.separator, props.decimals, props.decimal, props.formattingFn]);\n  React.useEffect(function () {\n    return function () {\n      reset();\n    };\n  }, [reset]);\n  return {\n    start: restart,\n    pauseResume: pauseResume,\n    reset: reset,\n    update: update,\n    getCountUp: getCountUp\n  };\n};\n\nvar _excluded = [\"className\", \"redraw\", \"containerProps\", \"children\", \"style\"];\nvar CountUp = function CountUp(props) {\n  var className = props.className,\n    redraw = props.redraw,\n    containerProps = props.containerProps,\n    children = props.children,\n    style = props.style,\n    useCountUpProps = _objectWithoutProperties(props, _excluded);\n  var containerRef = React.useRef(null);\n  var isInitializedRef = React.useRef(false);\n  var _useCountUp = useCountUp(_objectSpread2(_objectSpread2({}, useCountUpProps), {}, {\n      ref: containerRef,\n      startOnMount: typeof children !== 'function' || props.delay === 0,\n      // component manually restarts\n      enableReinitialize: false\n    })),\n    start = _useCountUp.start,\n    reset = _useCountUp.reset,\n    updateCountUp = _useCountUp.update,\n    pauseResume = _useCountUp.pauseResume,\n    getCountUp = _useCountUp.getCountUp;\n  var restart = useEventCallback(function () {\n    start();\n  });\n  var update = useEventCallback(function (end) {\n    if (!props.preserveValue) {\n      reset();\n    }\n    updateCountUp(end);\n  });\n  var initializeOnMount = useEventCallback(function () {\n    if (typeof props.children === 'function') {\n      // Warn when user didn't use containerRef at all\n      if (!(containerRef.current instanceof Element)) {\n        console.error(\"Couldn't find attached element to hook the CountUp instance into! Try to attach \\\"containerRef\\\" from the render prop to a an Element, eg. <span ref={containerRef} />.\");\n        return;\n      }\n    }\n\n    // unlike the hook, the CountUp component initializes on mount\n    getCountUp();\n  });\n  React.useEffect(function () {\n    initializeOnMount();\n  }, [initializeOnMount]);\n  React.useEffect(function () {\n    if (isInitializedRef.current) {\n      update(props.end);\n    }\n  }, [props.end, update]);\n  var redrawDependencies = redraw && props;\n\n  // if props.redraw, call this effect on every props change\n  React.useEffect(function () {\n    if (redraw && isInitializedRef.current) {\n      restart();\n    }\n  }, [restart, redraw, redrawDependencies]);\n\n  // if not props.redraw, call this effect only when certain props are changed\n  React.useEffect(function () {\n    if (!redraw && isInitializedRef.current) {\n      restart();\n    }\n  }, [restart, redraw, props.start, props.suffix, props.prefix, props.duration, props.separator, props.decimals, props.decimal, props.className, props.formattingFn]);\n  React.useEffect(function () {\n    isInitializedRef.current = true;\n  }, []);\n  if (typeof children === 'function') {\n    // TypeScript forces functional components to return JSX.Element | null.\n    return children({\n      countUpRef: containerRef,\n      start: start,\n      reset: reset,\n      update: updateCountUp,\n      pauseResume: pauseResume,\n      getCountUp: getCountUp\n    });\n  }\n  return /*#__PURE__*/React.createElement(\"span\", _extends({\n    className: className,\n    ref: containerRef,\n    style: style\n  }, containerProps), typeof props.start !== 'undefined' ? getCountUp().formattingFn(props.start) : '');\n};\n\nexports.default = CountUp;\nexports.useCountUp = useCountUp;\n","import { formatAmount } from '@/lib/utils'\nimport Image from 'next/image'\nimport Link from 'next/link'\nimport React from 'react'\nimport Copy from './Copy'\n\nconst BankCard = ({ account, userName, showBalance = true }: CreditCardProps) => {\n\n  console.log(account);\n  return (\n    <div className=\"flex flex-col\">\n      <Link href={`/transaction-history/?id=${account.appwriteItemId}`} className=\"bank-card\">\n        <div className=\"bank-card_content\">\n          <div>\n            <h1 className=\"text-16 font-semibold text-white\">\n              {account.name}\n            </h1>\n            <p className=\"font-ibm-plex-serif font-black text-white\">\n              {formatAmount(account.currentBalance)}\n            </p>\n          </div>\n\n          <article className=\"flex flex-col gap-2\">\n            <div className=\"flex justify-between\">\n              <h1 className=\"text-12 font-semibold text-white\">\n                {userName}\n              </h1>\n              <h2 className=\"text-12 font-semibold text-white\">\n              ●● / ●●\n              </h2>\n            </div>\n            <p className=\"text-14 font-semibold tracking-[1.1px] text-white\">\n              ●●●● ●●●● ●●●● <span className=\"text-16\">{account?.mask}</span>\n            </p>\n          </article>\n        </div>\n\n        <div className=\"bank-card_icon\">\n          <Image \n            src=\"/icons/Paypass.svg\"\n            width={20}\n            height={24}\n            alt=\"pay\"\n          />\n          <Image \n            src=\"/icons/mastercard.svg\"\n            width={45}\n            height={32}\n            alt=\"mastercard\"\n            className=\"ml-5\"\n          />\n        </div>\n\n        <Image \n          src=\"/icons/lines.png\"\n          width={316}\n          height={190}\n          alt=\"lines\"\n          className=\"absolute top-0 left-0\"\n        />\n      </Link>\n\n      {showBalance && <Copy title={account?.sharaebleId} />}\n    </div>\n  )\n}\n\nexport default BankCard","export default {\n  xmlns: 'http://www.w3.org/2000/svg',\n  width: 24,\n  height: 24,\n  viewBox: '0 0 24 24',\n  fill: 'none',\n  stroke: 'currentColor',\n  strokeWidth: 2,\n  strokeLinecap: 'round',\n  strokeLinejoin: 'round',\n};\n","/**\n * Converts string to KebabCase\n *\n * @param {string} string\n * @returns {string} A kebabized string\n */\nexport const toKebabCase = (string: string) =>\n  string.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();\n","import {\n  forwardRef,\n  createElement,\n  ReactSVG,\n  SVGProps,\n  ForwardRefExoticComponent,\n  RefAttributes,\n} from 'react';\nimport defaultAttributes from './defaultAttributes';\nimport { toKebabCase } from '@lucide/shared';\n\nexport type IconNode = [elementName: keyof ReactSVG, attrs: Record<string, string>][];\n\nexport type SVGAttributes = Partial<SVGProps<SVGSVGElement>>;\ntype ComponentAttributes = RefAttributes<SVGSVGElement> & SVGAttributes;\n\nexport interface LucideProps extends ComponentAttributes {\n  size?: string | number;\n  absoluteStrokeWidth?: boolean;\n}\n\nexport type LucideIcon = ForwardRefExoticComponent<LucideProps>;\n\nconst createLucideIcon = (iconName: string, iconNode: IconNode): LucideIcon => {\n  const Component = forwardRef<SVGSVGElement, LucideProps>(\n    (\n      {\n        color = 'currentColor',\n        size = 24,\n        strokeWidth = 2,\n        absoluteStrokeWidth,\n        className = '',\n        children,\n        ...rest\n      },\n      ref,\n    ) => {\n      return createElement(\n        'svg',\n        {\n          ref,\n          ...defaultAttributes,\n          width: size,\n          height: size,\n          stroke: color,\n          strokeWidth: absoluteStrokeWidth\n            ? (Number(strokeWidth) * 24) / Number(size)\n            : strokeWidth,\n          className: ['lucide', `lucide-${toKebabCase(iconName)}`, className].join(' '),\n          ...rest,\n        },\n        [\n          ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),\n          ...(Array.isArray(children) ? children : [children]),\n        ],\n      );\n    },\n  );\n\n  Component.displayName = `${iconName}`;\n\n  return Component;\n};\n\nexport default createLucideIcon;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ArrowUpRight\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNNyA3aDEwdjEwIiAvPgogIDxwYXRoIGQ9Ik03IDE3IDE3IDciIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/arrow-up-right\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ArrowUpRight = createLucideIcon('ArrowUpRight', [\n  ['path', { d: 'M7 7h10v10', key: '1tivn9' }],\n  ['path', { d: 'M7 17 17 7', key: '1vkiza' }],\n]);\n\nexport default ArrowUpRight;\n","import Link from 'next/link';\nimport { ArrowUpRight } from 'lucide-react';\n\nconst LegalBanner = () => {\n  return (\n    <section className=\"legal-banner\">\n      <div className=\"flex-1 space-y-1\">\n        <p className=\"text-sm font-semibold text-brand-700\">Regulatory Notice</p>\n        <p className=\"text-sm text-gray-600\">\n          Horizon provides digital wealth management services with FDIC-insured sweep programs. Transaction availability may vary by jurisdiction.\n          Please review the latest legal disclosures before completing a transfer.\n        </p>\n      </div>\n      <div className=\"flex items-center gap-3\">\n        <Link className=\"legal-banner__cta\" href=\"/legal/disclaimer\">\n          View full disclaimer\n          <ArrowUpRight className=\"h-4 w-4\" />\n        </Link>\n      </div>\n    </section>\n  );\n};\n\nexport default LegalBanner;\n","export { default } from \"../client/link\";\nexport * from \"../client/link\";\n\n//# sourceMappingURL=link.js.map"],"names":["module","exports","require","wrappedServerComponent","components_RecentTransactions","accounts","transactions","appwriteItemId","page","totalPages","Math","ceil","length","indexOfLastTransaction","currentTransactions","slice","react_jsx_runtime","jsxs","section","className","header","jsx","h2","div","ManualTransactionSheet","defaultBankId","Link","href","Tabs","defaultValue","TabsList","map","TabsTrigger","value","account","BankTabItem","id","TabsContent","BankInfo","type","TransactionsTable","Pagination","components_Category","category","bg","circleBg","text","main","count","progress","progressBg","indicator","icon","topCategoryStyles","name","default","cn","figure","Image","src","width","height","alt","h3","Progress","totalCount","indicatorClassName","components_RightSidebar","user","banks","categories","countTransactionCategories","aside","span","firstName","h1","lastName","p","email","BankCard","userName","showBalance","$id","index","Category","components_TotalBalanceBox","totalBanks","totalCurrentBalance","DoughnutChart","AnimatedCounter","amount","Proxy","searchParams","currentPage","Number","loggedIn","getLoggedInUser","getAccounts","userId","accountsData","data","getAccount","_jsxs","_jsx","HeaderBox","title","subtext","LegalBanner","TotalBalanceBox","RecentTransactions","RightSidebar","apply","originalFunction","thisArg","args","sentryTraceHeader","baggageHeader","headers","requestAsyncStore","request_async_storage_external_js_","requestAsyncStorage","getStore","_nullishCoalesce","h","_optionalChain","x","_","_2","get","_3","undefined","_4","_5","_6","_7","e","wrapServerComponentWithSentry","D","componentRoute","componentType","generateMetadata","generateImageMetadata","generateViewport","wrappedServerComponent$1","tree","children","Promise","resolve","then","__webpack_require__","bind","t","pages","originalPathname","__next_app__","loadChunk","routeModule","next_dist_server_future_route_modules_app_page_module_compiled__WEBPACK_IMPORTED_MODULE_4__","AppPageRouteModule","definition","kind","next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_5__","APP_PAGE","pathname","bundlePath","filename","appPaths","userland","loaderTree","__WEBPACK_DEFAULT_EXPORT__","react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__","CountUp","decimals","decimal","prefix","end","router","useRouter","useSearchParams","isActive","colors","getAccountTypeColors","onClick","newUrl","formUrlQuery","params","toString","key","push","scroll","lightBg","subtype","subText","formatAmount","currentBalance","hasCopied","setHasCopied","useState","Button","data-state","variant","navigator","clipboard","writeText","setTimeout","svg","xmlns","viewBox","fill","stroke","stroke-width","stroke-linecap","stroke-linejoin","polyline","points","rect","y","rx","ry","path","d","names","round","v","lim","l","max","min","p2b","n2b","b2n","n2p","map$1","A","B","C","E","F","a","b","c","f","hex","eq","isShort","r","g","alpha","HUE_RE","hsl2rgbn","s","n","k","hsv2rgbn","hwb2rgbn","w","i","rgb","rgb2hsl","calln","Array","isArray","hue","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","RGB_RE","to","pow","from","modHSL","ratio","tmp","clone","proto","Object","assign","fromObject","input","Color","constructor","hexParse","str","ret","len","nameParse","unpack","j","ok","nk","unpacked","keys","tkeys","replace","parseInt","transparent","toLowerCase","functionParse","charAt","rgbParse","m","exec","hueParse","p1","p2","_rgb","_valid","valid","obj","rgbString","hexString","hslString","mix","color","weight","w2","c1","c2","w1","interpolate","rgb1","rgb2","clearer","greyscale","val","opaquer","negate","lighten","darken","saturate","desaturate","rotate","deg","noop","uid","isNullOrUndef","prototype","call","isObject","isNumberFinite","isFinite","finiteOrDefault","valueOrDefault","toPercentage","dimension","endsWith","parseFloat","toDimension","callback","fn","each","loopable","reverse","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","helpers_dataset_clone","source","target","create","klen","isValidKey","indexOf","_merger","options","tval","sval","merge","current","sources","merger","mergeIf","_mergerIf","hasOwnProperty","keyResolvers","o","resolveObjectKey","resolver","_getKeyResolver","_splitKey","parts","split","part","_capitalize","toUpperCase","defined","isFunction","setsEqual","size","item","has","PI","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","almostEquals","epsilon","abs","niceNum","range","roundedRange","niceRange","floor","fraction","niceFraction","isNumber","Symbol","toPrimitive","isNaN","_setMinAndMaxByKey","array","property","toRadians","degrees","_decimalPlaces","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","angle","atan2","distance","sqrt","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","start","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_isBetween","_lookup","table","cmp","mid","hi","lo","_lookupByKey","last","ti","_rlookupByKey","arrayEvents","unlistenArrayEvents","listener","stub","_chartjs","listeners","splice","forEach","_arrayUnique","items","set","Set","requestAnimFrame","window","requestAnimationFrame","throttled","argsToUse","ticking","_toLeftRightCenter","align","_alignStartEnd","_textX","left","right","rtl","_getStartAndCountOfVisiblePoints","meta","animationsDisabled","pointCount","_sorted","iScale","vScale","_parsed","spanGaps","dataset","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","distanceToDefinedLo","findIndex","point","distanceToDefinedHi","_scaleRangesChanged","xScale","yScale","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","changed","atEdge","elasticIn","sin","elasticOut","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","isPatternOrGradient","getHoverColor","numbers","intlCache","Map","formatNumber","num","locale","getNumberFormat","cacheKey","JSON","stringify","formatter","Intl","NumberFormat","format","formatters","values","numeric","tickValue","ticks","notation","chart","delta","maxTick","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","includes","significand","Ticks","overrides","descriptors","getScope$1","node","root","scope","Defaults","_descriptors","_appliers","animation","backgroundColor","borderColor","datasets","devicePixelRatio","context","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","hover","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","enumerable","local","appliers","defaults","_scriptable","startsWith","_indexable","_fallback","delay","duration","easing","loop","properties","active","resize","show","animations","visible","hide","autoPadding","padding","top","bottom","display","offset","beginAtZero","bounds","clip","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","_ctx","tickColor","border","dash","dashOffset","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","_measureText","gc","longest","string","textWidth","measureText","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","clearCanvas","canvas","getContext","save","resetTransform","clearRect","restore","drawPoint","drawPointLegend","xOffset","yOffset","cornerRadius","xOffsetW","yOffsetW","pointStyle","rotation","radius","rad","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","lineTo","SQRT1_2","borderWidth","_isPointInArea","area","margin","clipArea","unclipArea","_steppedLineTo","previous","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","renderText","opts","line","lines","strokeWidth","strokeColor","translation","fillStyle","textAlign","textBaseline","backdrop","drawBackdrop","oldColor","fillRect","strokeStyle","strokeText","maxWidth","fillText","decorateText","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","decorationWidth","addRoundedRectPath","topLeft","bottomLeft","bottomRight","topRight","LINE_HEIGHT","FONT_STYLE","numberOrZero","_readValueToProps","props","objProps","read","prop","toTRBL","toTRBLCorners","toPadding","toFont","fallback","match","console","warn","toLineHeight","matches","inputs","info","cacheable","createContext","parentContext","_createResolver","scopes","prefixes","rootScopes","getTarget","finalRootScopes","_resolve","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","deleteProperty","_keys","_cached","_resolveWithPrefixes","proxy","readKey","needsSubResolver","createSubResolver","getOwnPropertyDescriptor","Reflect","getPrototypeOf","getKeysFromAllScopes","ownKeys","storage","_storage","_attachContext","subProxy","descriptorDefaults","_proxy","_context","_subProxy","_stack","setContext","receiver","_resolveWithContext","isScriptable","_resolveScriptable","getValue","join","add","delete","_resolveArray","isIndexable","arr","filter","allKeys","configurable","scriptable","indexable","_allKeys","getScope","parent","parentScopes","allScopes","addScopesFromKey","subGetTarget","addScopes","parentFallback","resolveKeysFromAllScopes","_parseObjectDataRadialScale","_parsing","parsed","parse","EPSILON","getPoint","skip","getValueAxis","capControlPoint","pt","_isDomSupported","document","_getParentNode","domNode","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","element","ownerDocument","defaultView","positions","getPositionedStyle","styles","suffix","result","pos","useOffsetPos","shadowRoot","getRelativePosition","event","borderBox","boxSizing","paddings","borders","box","getCanvasPosition","touches","offsetX","offsetY","getBoundingClientRect","clientX","clientY","round1","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","passive","addEventListener","removeEventListener","readUsedSize","getPropertyValue","_pointInLine","_steppedInterpolation","_bezierInterpolation","cp1","cp2","getRtlAdapter","rectX","setWidth","xPlus","leftForLtr","itemWidth","_itemWidth","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalize","normalizeSegment","_boundSegment","segment","prevValue","startBound","endBound","getSegment","inside","subStart","startIsBefore","endIsBefore","shouldStart","shouldStop","prev","_boundSegments","segments","sub","splitByStyles","segmentOptions","doSplitByStyles","chartContext","_chart","baseStyle","readStyle","_datasetIndex","prevStyle","addStyle","st","dir","styleChanged","cache","replacer","p0","p0DataIndex","p1DataIndex","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","getSizeForArea","chartArea","field","Animator","_request","_charts","_running","_lastDate","_notify","anims","date","callbacks","numSteps","initial","currentStep","_refresh","_update","Date","now","remaining","running","draw","_active","_total","tick","pop","_getAnims","charts","complete","listen","cb","reduce","acc","cur","_duration","stop","cancel","remove","animator","interpolators","boolean","factor","c0","number","Animation","cfg","currentValue","_fn","_easing","_start","_loop","_target","_prop","_from","_to","_promises","update","elapsed","remain","wait","promises","res","rej","resolved","method","Animations","config","_properties","configure","animationOptions","animatedProps","getOwnPropertyNames","option","_animateOptions","newOptions","resolveTargetOptions","$shared","$animations","_createAnimations","awaitAll","anim","all","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","metasets","_getSortedDatasetMetas","applyStack","stack","dsIndex","otherValue","singleMode","found","isStacked","stacked","getLastIndexInStack","positive","getMatchingVisibleMetas","updateStacks","controller","_cachedMeta","stacks","_stacks","iAxis","vAxis","indexScale","valueScale","itemStacks","getOrCreateStack","stackKey","indexValue","subStack","_top","_bottom","visualValues","_visualValues","getFirstScaleId","shift","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","createStack","canStack","hidden","_stacked","DatasetController","datasetElementType","dataElementType","_cachedDataOpts","getMeta","_type","_data","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","initialize","linkScales","addElements","isPluginEnabled","updateIndex","getDataset","chooseId","xid","xAxisID","yid","yAxisID","rid","rAxisID","iid","iAxisID","vid","vAxisID","getScaleForId","rScale","getDatasetMeta","scaleID","_getOtherScale","reset","_destroy","_dataCheck","convertObjectDataToArray","iAxisKey","vAxisKey","adata","isExtensible","listenArrayEvents","defineProperty","base","object","buildOrUpdateElements","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","getOptionScopes","createResolver","sorted","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","labels","getLabels","singleScale","xAxisKey","yAxisKey","getParsed","getDataElement","updateRangeFromParsed","parsedValue","NaN","getMinMax","otherScale","NEGATIVE_INFINITY","otherMin","otherMax","_skip","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","defaultClip","disabled","getStyle","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","raw","_resolveElementOptions","elementType","sharing","datasetElementScopeKeys","resolveNamedOptions","freeze","_resolveAnimations","transition","datasetAnimationScopeKeys","getSharedOptions","includeOptions","sharedOptions","_animationsDisabled","_getSharedOptions","firstOpts","previouslySharedOptions","updateSharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","move","updateElements","removed","_sync","_dataChanges","_onDataPush","arguments","_onDataPop","_onDataShift","_onDataSplice","newCount","_onDataUnshift","parseValue","entry","parseFloatBar","startValue","endValue","barStart","barEnd","_custom","parseArrayOrPrimitive","isFloatBar","custom","parseEdge","edge","orig","startEnd","chart_BarController","categoryPercentage","barPercentage","grouped","_index_","_value_","bars","getBasePixel","horizontal","isHorizontal","ruler","_getRuler","vpixels","head","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","enableBorderRadius","center","setBorderSkipped","borderSkipped","setInflateAmount","inflateAmount","_getStacks","currentParsed","iScaleValue","skipNull","find","_getStackCount","_getAxisCount","_getAxis","getFirstScaleIdForIndexAxis","indexScaleId","firstScaleAxisId","_getStackIndex","pixels","barThickness","computeMinSampleSize","curr","getAllScaleValues","_cache","$bar","visibleMetas","concat","sort","_length","updateMinAndPrev","getPixelForTick","_startPixel","_endPixel","stackCount","baseValue","minBarLength","actualBase","floating","getDataVisibility","startPixel","getPixelForDecimal","endPixel","getValueForPixel","halfGrid","getLineWidthForValue","maxBarThickness","Infinity","axisCount","computeFlexCategoryTraits","next","percent","chunk","computeFitCategoryTraits","thickness","axisID","axisNumber","stackIndex","rects","chart_BubbleController","iPixel","vPixel","DoughnutController","animateRotate","animateScale","cutout","circumference","spacing","aspectRatio","legend","generateLabels","fontColor","legendItem","toggleDataVisibility","innerRadius","outerRadius","getter","_getRotation","_getCircumference","_getRotationExtents","isDatasetVisible","arcs","getMaxBorderWidth","getMaxOffset","maxSize","chartWeight","_getRingWeight","ratioX","ratioY","getRatioAndOffset","endAngle","startAngle","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","maxHeight","radiusLength","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","animationOpts","centerX","centerY","metaData","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","chart_LineController","_dataset","_decimated","animated","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","updateControlPoints","chart_PolarAreaController","angleLines","circular","pointLabels","_updateRadius","minSize","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","chart_PieController","chart_RadarController","_fullLoop","pointPosition","getPointPositionForValue","chart_ScatterController","registry","getElement","chart_abstract","DateAdapterBase","members","init","formats","diff","startOf","endOf","adapters","_date","evaluateInteractionItems","position","handler","getSortedVisibleDatasetMetas","binarySearch","metaset","lookupMethod","_reversePixels","el","getRange","getIntersectItems","useFinalPosition","isPointInArea","inRange","getNearestItems","getNearestCartesianItems","distanceMetric","getDistanceMetricForAxis","useX","useY","minDistance","getCenterPoint","getProps","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","nearest","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","fitBoxes","boxes","layout","refit","refitBoxes","getMargins","same","other","updateDims","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","fullSize","setBoxDims","placeBoxes","userPadding","placed","stackWeight","layouts","addBox","_layers","z","removeBox","layoutItem","minPadding","availableWidth","availableHeight","buildLayoutBoxes","layoutBoxes","wrapBoxes","wrap","centerHorizontal","centerVertical","leftAndTop","rightAndBottom","vertical","verticalBoxes","horizontalBoxes","beforeLayout","vBoxMaxWidth","hBoxMaxHeight","setLayoutDims","buildStacks","handleMaxPadding","updatePos","change","BasePlatform","acquireContext","releaseContext","getMaximumSize","isAttached","updateConfig","BasicPlatform","EXPANDO_KEY","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","nodeListContains","nodeList","contains","createAttachObserver","observer","MutationObserver","trigger","entries","addedNodes","removedNodes","observe","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","container","clientWidth","ResizeObserver","contentRect","releaseObserver","disconnect","createProxyAndListen","fromNativeEvent","native","DomPlatform","initCanvas","renderHeight","getAttribute","renderWidth","displayWidth","displayHeight","removeAttribute","setAttribute","proxies","$proxies","handlers","attach","detach","bbWidth","bbHeight","margins","containerSize","getContainerSize","containerStyle","containerBorder","containerPadding","clientHeight","isConnected","Element","defaultRoutes","tooltipPosition","hasValue","final","newTicks","majorStart","majorEnd","reverseAlign","offsetFromEdge","getTicksLimit","ticksLength","maxTicksLimit","sample","numItems","increment","getTickMarkLength","getTitleHeight","Scale","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_maxLength","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_dataLimitsCached","suggestedMin","suggestedMax","metas","getTicks","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","tickOpts","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","_addGrace","minmax","keepZero","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","determinedMaxTicks","determineMaxTicks","_tickSize","ticksLimit","majorIndices","enabled","getMajorIndices","numMajorIndices","first","skipMajors","calculateSpacing","evenMajorSpacing","getEvenSpacing","factors","_factorize","avgMajorSpacing","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","reversePixels","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","maxLabelDiagonal","numTicks","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","radians","asin","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","isFullSize","_computeLabelSizes","jlen","tickFont","fontString","nestedLabel","caches","widths","heights","widestLabelSize","highestLabelSize","_resolveTickFontOptions","gcLen","valueAt","idx","getDecimalForPixel","getBaseValue","optionTicks","rot","_computeGridLineItems","borderValue","lineValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","positionAxisID","limit","step","optsAtIndex","optsAtIndexBorder","lineColor","tickBorderDash","tickBorderDashOffset","getPixelForGridLine","offsetGridLines","validIndex","lineCount","textOffset","tickAndPadding","hTickAndPadding","_getXAxisLabelAlignment","_getYAxisLabelAlignment","halfCount","tickTextAlign","labelPadding","_computeLabelArea","drawBackground","drawGrid","drawLine","setLineDash","lineDashOffset","drawBorder","lastLineWidth","drawLabels","renderTextOptions","drawTitle","titleX","titleY","titleArgs","tz","gz","bz","_maxDigits","fontSize","TypedRegistry","isForType","isPrototypeOf","register","parentScope","registerDefaults","itemDefaults","routeDefaults","routes","propertyParts","sourceName","sourceScope","unregister","Registry","controllers","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","typedRegistry","reg","_getRegistryForType","arg","_exec","itemReg","component","camelMethod","PluginService","_init","notify","hook","_createDescriptors","descriptor","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","allPlugins","localIds","createDescriptors","pluginOpts","pluginScopeKeys","previousDescriptors","some","getIndexAxis","datasetDefaults","datasetOptions","idMatchesAxis","determineAxis","scaleOptions","getAxisFromDataset","initOptions","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","error","retrieveAxisFromDatasets","boundDs","defaultId","defaultScaleOptions","defaultID","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","clearCache","clear","datasetType","additionalOptionScopes","_cachedScopes","mainScope","resetCache","keyLists","chartOptionScopes","subPrefixes","getResolver","needContext","hasFunction","subResolver","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getCanvas","getElementById","instances","getChart","Chart","version","invalidatePlugins","userConfig","initialCanvas","existingChart","OffscreenCanvas","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","debounce","timeout","clearTimeout","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","newSize","newRatio","onResize","render","ensureScalesHaveIDs","axisOptions","buildOrUpdateScales","scaleOpts","updated","isRadial","dposition","dtype","scaleType","hasUpdated","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","buildOrUpdateControllers","newControllers","order","ControllerClass","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","unbindEvents","_getUniformDataChanges","moveNumericKeys","intKey","datasetCount","makeSet","changeSet","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","getDatasetClipArea","getDatasetArea","getElementsAtEventForMode","setDatasetVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","_add","detached","_remove","updateHoverStyle","getActiveElements","setActiveElements","activeElements","lastActive","pluginId","replay","hoverOptions","deactivated","activated","inChartArea","eventFilter","_handleEvent","lastEvent","_getActiveElements","isClick","rThetaToXY","theta","pathArc","pixelMargin","innerR","spacingOffset","noSpacingOuterRadius","avNogSpacingRadius","noSpacingInnerRadius","beta","angleOffset","outerStart","outerEnd","innerStart","innerEnd","parseBorderRadius$1","angleDelta","borderRadius","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","ArcElement","selfJoin","fullCircles","chartX","chartY","rAdjust","nonZeroBetween","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","inner","lineJoin","clipArc","angleMargin","clipSelf","outerAngleClip","innerAngleClip","clipWidth","setStyle","lineCap","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","pathSegment","lineMethod","stepped","tension","cubicInterpolationMode","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","useFastPath","usePath2D","Path2D","LineElement","capBezierPoints","_path","_points","_segments","_pointsUpdated","_updateBezierControlPoints","controlPoints","splineCurveMonotone","pointBefore","pointCurrent","valueAxis","pointsLen","deltaK","mK","pointAfter","slopeDelta","monotoneAdjust","alphaK","betaK","tauK","squaredMagnitude","monotoneCompute","splineCurve","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fa","fb","inArea","inAreaPrev","inAreaNext","_computeSegments","findStartAndEnd","completeLoop","solidSegments","_interpolate","interpolated","segmentMethod","strokePathDirect","inRange$1","hitRadius","PointElement","hoverRadius","mouseX","mouseY","inXRange","inYRange","getBarBounds","bar","half","skipOrLimit","skipX","skipY","addNormalRectPath","inflateRect","refRect","BarElement","outer","boundingRects","parseBorderWidth","maxW","maxH","parseBorderRadius","maxR","enableBorder","addRectPath","hasRadius","_getBounds","_findSegmentEnd","_getEdge","interpolatedLineTo","interpolatedPoint","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","itemsEqual","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","col","fontLineHeight","legendItemText","calculateLegendItemHeight","adjustHitBoxes","rtlHelper","hitbox","_draw","cursor","defaultColor","halfFontSize","drawLegendBox","lineDash","SQRT2","yBoxTop","xBoxLeft","textDirection","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","hitBox","lh","handleEvent","onLeave","hoveredItem","sameItem","WeakMap","positioners","average","xSet","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","String","getTooltipSize","tooltip","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineAlignment","yAlign","determineYAlign","xAlign","determineXAlign","chartWidth","doesNotFitWithAlign","caret","caretSize","caretPadding","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","overrideCallbacks","defaultCallbacks","beforeTitle","tooltipItems","labelCount","afterTitle","beforeLabel","tooltipItem","formattedValue","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","invokeCallbackWithFallback","Tooltip","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","getTitle","getBeforeBody","getBody","bodyItems","scoped","getAfterBody","getFooter","_createItems","createTooltipItem","itemSort","positionAndSize","backgroundPoint","external","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","titleAlign","titleColor","_drawColorBox","colorX","rtlColorX","yOffSet","colorY","drawOptions","multiKeyBackground","outerX","innerX","strokeRect","drawBody","textColor","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","drawFooter","footerAlign","footerColor","tooltipSize","quadraticCurveTo","_updateAnimationTarget","animX","animY","_willRender","hasTooltipContent","globalAlpha","positionChanged","_positionChanged","_ignoreReplayEvents","addIfString","addedLabels","unshift","_getLabelForValue","CategoryScale","_startValue","_valueRange","_addedLabels","added","findOrAddLabel","lastIndexOf","relativeLabelSize","minSpacing","LinearScaleBase","_endValue","handleTickRangeOptions","setMin","setMax","minSign","maxSign","getTickLimit","maxTicks","stepSize","computeTickLimit","generateTicks$1","generationOptions","dataRange","niceMin","niceMax","numSpaces","precision","maxDigits","includeBounds","unit","maxSpaces","rmin","rmax","countDefined","almostWhole","rounded","decimalPlaces","LinearScale","log10Floor","changeExponent","isMajor","tickVal","steps","rangeExp","rangeStep","LogarithmicScale","_zero","generateTicks","minExp","exp","startExp","lastTick","getTickBackdropHeight","determineLimits","pathRadiusLine","getPointPosition","RadialLinearScale","animate","centerPointLabels","drawingArea","_pointLabels","_pointLabelItems","_padding","fitWithPointLabels","limits","valueCount","pointLabelOpts","additionalAngle","getPointLabelContext","plFont","textSize","_longestText","arrayOfThings","thing","nestedThing","garbageCollect","updateLimits","hLimits","vLimits","setCenterPoint","buildPointLabelItems","itemOpts","extra","createPointLabelItem","outerDistance","pointLabelPosition","isNotOverlapped","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","getValueForDistanceFromCenter","scaledDistance","pointLabel","distanceFromCenter","getBasePosition","getPointLabelPosition","drawPointLabels","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","drawRadiusLine","gridLineOpts","INTERVALS","millisecond","common","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","adapter","_adapter","parser","isoWeekday","_parseOpts","determineUnitForAutoTicks","minUnit","capacity","interval","MAX_SAFE_INTEGER","addTick","time","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","TimeScale","displayFormats","_unit","_majorUnit","_offsets","_normalized","normalized","_applyBounds","_getLabelBounds","getLabelTimestamps","timeOpts","_generate","_filterBetween","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","initOffsets","offsetAfterAutoskip","getDecimalForValue","weekday","hasWeekday","getDataTimestamps","tooltipFormat","datetime","fmt","_tickFormatFunction","minorFormat","majorFormat","offsets","_getLabelSize","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","chart_interpolate","prevSource","nextSource","prevTarget","nextTarget","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","defaultDatasetIdKey","reforwardRef","ref","setDatasets","currentData","nextDatasets","datasetIdKey","addedDatasets","currentDataset","nextDataset","dist_Chart","react","forwardRef","redraw","fallbackContent","updateMode","canvasProps","canvasRef","useRef","chartRef","renderChart","cloneData","nextLabels","nextData","destroyChart","useEffect","setOptions","nextOptions","createElement","role","Doughnut","ChartJS","_element","afterInit","_args","afterDraw","afterEvent","ci","useBorderRadius","components_DoughnutChart","accountNames","balances","handleNavigation","pageNumber","PROGRESS_NAME","createProgressContext","createProgressScope","createContextScope","ProgressProvider","useProgressContext","React","forwardedRef","propValue","__scopeProgress","valueProp","maxProp","getValueLabel","defaultGetValueLabel","progressProps","isValidMaxNumber","isValidValueNumber","valueLabel","Primitive","getProgressState","displayName","INDICATOR_NAME","ProgressIndicator","indicatorProps","maxValue","transform","ProgressPrimitive","ENTRY_FOCUS","EVENT_OPTIONS","bubbles","GROUP_NAME","Collection","useCollection","createCollectionScope","createCollection","createRovingFocusGroupContext","createRovingFocusGroupScope","RovingFocusProvider","useRovingFocusContext","RovingFocusGroup","Provider","__scopeRovingFocusGroup","Slot","RovingFocusGroupImpl","orientation","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","preventScrollOnEntryFocus","groupProps","composedRefs","useComposedRefs","useDirection","setCurrentTabStopId","useControllableState","defaultProp","onChange","caller","isTabbingBackOut","setIsTabbingBackOut","handleEntryFocus","useCallbackRef","getItems","isClickFocusRef","focusableItemsCount","setFocusableItemsCount","onItemFocus","tabStopId","onItemShiftTab","onFocusableItemAdd","prevCount","onFocusableItemRemove","tabIndex","outline","onMouseDown","composeEventHandlers","onFocus","isKeyboardFocus","currentTarget","entryFocusEvent","CustomEvent","dispatchEvent","defaultPrevented","focusable","focusFirst","candidateItems","Boolean","onBlur","ITEM_NAME","RovingFocusGroupItem","itemProps","autoId","useId","isCurrentTabStop","ItemSlot","preventDefault","onKeyDown","shiftKey","focusIntent","getFocusIntent","MAP_KEY_TO_FOCUS_INTENT","metaKey","ctrlKey","altKey","candidateNodes","currentIndex","wrapArray","startIndex","hasTabStop","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","candidates","preventScroll","PREVIOUSLY_FOCUSED_ELEMENT","activeElement","candidate","focus","TABS_NAME","createTabsContext","createTabsScope","useRovingFocusGroupScope","TabsProvider","useTabsContext","__scopeTabs","onValueChange","activationMode","tabsProps","setValue","baseId","TAB_LIST_NAME","listProps","rovingFocusGroupScope","asChild","TRIGGER_NAME","triggerProps","triggerId","makeTriggerId","contentId","makeContentId","isSelected","button","isAutomaticActivation","CONTENT_NAME","forceMount","contentProps","isMountAnimationPreventedRef","rAF","cancelAnimationFrame","Presence","present","animationDuration","TabsPrimitive","endVal","startVal","useEasing","useGrouping","useIndianSeparators","smartEasingThreshold","smartEasingAmount","separator","enableScrollSpy","scrollSpyDelay","scrollSpyOnce","finalEndVal","countDown","paused","once","startTime","frameVal","easingFn","toFixed","printValue","onCompleteCallback","u","numerals","formattingFn","innerHTML","validateValue","resetDuration","onScrollFns","handleScroll","onscroll","innerHeight","scrollY","pageYOffset","determineDirectionAndSmartEasing","onStartCallback","pauseResume","tagName","textContent","ensureNumber","countup_js","getOwnPropertySymbols","_objectSpread2","_defineProperty","_toPrimitive","getOwnPropertyDescriptors","_extends","_objectWithoutProperties","excluded","_objectWithoutPropertiesLoose","sourceKeys","sourceSymbolKeys","propertyIsEnumerable","_arrayLikeToArray","arr2","useIsomorphicLayoutEffect","useLayoutEffect","useEventCallback","useCallback","_len","_key","createCountUpInstance","_excluded$1","DEFAULTS","startOnMount","enableReinitialize","useCountUp","filteredProps","fromEntries","_ref","_ref2","_arrayWithHoles","_iterableToArrayLimit","iterator","done","return","_unsupportedIterableToArray","minLen","test","_nonIterableRest","_useMemo","useMemo","onEnd","onStart","onPauseResume","onReset","onUpdate","instanceProps","countUpRef","timerRef","isInitializedRef","createInstance","getCountUp","recreate","countUp","newCountUp","run","restart","newEnd","maybeInitialize","shouldReset","_excluded","ZP","containerProps","useCountUpProps","containerRef","_useCountUp","updateCountUp","preserveValue","initializeOnMount","redrawDependencies","components_BankCard","log","article","mask","Copy","sharaebleId","defaultAttributes","strokeLinecap","strokeLinejoin","toKebabCase","ArrowUpRight","createLucideIcon","iconName","iconNode","Component","absoluteStrokeWidth","rest","tag","attrs","components_LegalBanner"],"sourceRoot":""}