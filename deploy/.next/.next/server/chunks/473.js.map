{"version":3,"file":"473.js","mappings":"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","sources":["webpack://jsm_banking/../../../src/icons/check.ts","webpack://jsm_banking/../../../src/icons/chevron-down.ts","webpack://jsm_banking/../../../src/icons/chevron-up.ts","webpack://jsm_banking/../src/collection-legacy.tsx","webpack://jsm_banking/../src/collection.tsx","webpack://jsm_banking/../src/ordered-dictionary.ts","webpack://jsm_banking/./node_modules/@radix-ui/react-direction/dist/index.mjs","webpack://jsm_banking/./node_modules/@radix-ui/number/dist/index.mjs","webpack://jsm_banking/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","webpack://jsm_banking/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs","webpack://jsm_banking/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","webpack://jsm_banking/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","webpack://jsm_banking/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs","webpack://jsm_banking/./node_modules/@radix-ui/react-arrow/dist/index.mjs","webpack://jsm_banking/./node_modules/@radix-ui/react-use-size/dist/index.mjs","webpack://jsm_banking/../src/popper.tsx","webpack://jsm_banking/./node_modules/@radix-ui/react-use-previous/dist/index.mjs","webpack://jsm_banking/./node_modules/@radix-ui/react-visually-hidden/dist/index.mjs","webpack://jsm_banking/../src/select.tsx"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name Check\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjAgNiA5IDE3bC01LTUiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/check\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Check = createLucideIcon('Check', [['path', { d: 'M20 6 9 17l-5-5', key: '1gmf2c' }]]);\n\nexport default Check;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ChevronDown\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtNiA5IDYgNiA2LTYiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/chevron-down\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChevronDown = createLucideIcon('ChevronDown', [\n  ['path', { d: 'm6 9 6 6 6-6', key: 'qrunsl' }],\n]);\n\nexport default ChevronDown;\n","import createLucideIcon from '../createLucideIcon';\n\n/**\n * @component @name ChevronUp\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMTggMTUtNi02LTYgNiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/chevron-up\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChevronUp = createLucideIcon('ChevronUp', [['path', { d: 'm18 15-6-6-6 6', key: '153udz' }]]);\n\nexport default ChevronUp;\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>…</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData = {}>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement | null>;\n    itemMap: Map<\n      React.RefObject<ItemElement | null>,\n      { ref: React.RefObject<ItemElement | null> } & ItemData\n    >;\n  };\n\n  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    { collectionRef: { current: null }, itemMap: new Map() }\n  );\n\n  const CollectionProvider: React.FC<{ children?: React.ReactNode; scope: any }> = (props) => {\n    const { scope, children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <CollectionProviderImpl scope={scope} itemMap={itemMap} collectionRef={ref}>\n        {children}\n      </CollectionProviderImpl>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...(itemData as unknown as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const context = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    const getItems = React.useCallback(() => {\n      const collectionNode = context.collectionRef.current;\n      if (!collectionNode) return [];\n      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));\n      const items = Array.from(context.itemMap.values());\n      const orderedItems = items.sort(\n        (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n      );\n      return orderedItems;\n    }, [context.collectionRef, context.itemMap]);\n\n    return getItems;\n  }\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    useCollection,\n    createCollectionScope,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n","import React from 'react';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createSlot, type Slot } from '@radix-ui/react-slot';\nimport type { EntryOf } from './ordered-dictionary';\nimport { OrderedDict } from './ordered-dictionary';\n\ntype SlotProps = React.ComponentPropsWithoutRef<typeof Slot>;\ntype CollectionElement = HTMLElement;\ninterface CollectionProps extends SlotProps {\n  scope: any;\n}\n\ninterface BaseItemData {\n  id?: string;\n}\n\ntype ItemDataWithElement<\n  ItemData extends BaseItemData,\n  ItemElement extends HTMLElement,\n> = ItemData & {\n  element: ItemElement;\n};\n\ntype ItemMap<ItemElement extends HTMLElement, ItemData extends BaseItemData> = OrderedDict<\n  ItemElement,\n  ItemDataWithElement<ItemData, ItemElement>\n>;\n\nfunction createCollection<\n  ItemElement extends HTMLElement,\n  ItemData extends BaseItemData = BaseItemData,\n>(name: string) {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  const PROVIDER_NAME = name + 'CollectionProvider';\n  const [createCollectionContext, createCollectionScope] = createContextScope(PROVIDER_NAME);\n\n  type ContextValue = {\n    collectionElement: CollectionElement | null;\n    collectionRef: React.Ref<CollectionElement | null>;\n    collectionRefObject: React.RefObject<CollectionElement | null>;\n    itemMap: ItemMap<ItemElement, ItemData>;\n    setItemMap: React.Dispatch<React.SetStateAction<ItemMap<ItemElement, ItemData>>>;\n  };\n\n  const [CollectionContextProvider, useCollectionContext] = createCollectionContext<ContextValue>(\n    PROVIDER_NAME,\n    {\n      collectionElement: null,\n      collectionRef: { current: null },\n      collectionRefObject: { current: null },\n      itemMap: new OrderedDict(),\n      setItemMap: () => void 0,\n    }\n  );\n\n  type CollectionState = [\n    ItemMap: ItemMap<ItemElement, ItemData>,\n    SetItemMap: React.Dispatch<React.SetStateAction<ItemMap<ItemElement, ItemData>>>,\n  ];\n\n  const CollectionProvider: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n    state?: CollectionState;\n  }> = ({ state, ...props }) => {\n    return state ? (\n      <CollectionProviderImpl {...props} state={state} />\n    ) : (\n      <CollectionInit {...props} />\n    );\n  };\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  const CollectionInit: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n  }> = (props) => {\n    const state = useInitCollection();\n    return <CollectionProviderImpl {...props} state={state} />;\n  };\n  CollectionInit.displayName = PROVIDER_NAME + 'Init';\n\n  const CollectionProviderImpl: React.FC<{\n    children?: React.ReactNode;\n    scope: any;\n    state: CollectionState;\n  }> = (props) => {\n    const { scope, children, state } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const [collectionElement, setCollectionElement] = React.useState<CollectionElement | null>(\n      null\n    );\n    const composeRefs = useComposedRefs(ref, setCollectionElement);\n    const [itemMap, setItemMap] = state;\n\n    React.useEffect(() => {\n      if (!collectionElement) return;\n\n      const observer = getChildListObserver(() => {\n        // setItemMap((map) => {\n        //   const copy = new OrderedDict(map).toSorted(([, a], [, b]) =>\n        //     !a.element || !b.element ? 0 : isElementPreceding(a.element, b.element) ? -1 : 1\n        //   );\n        //   // check if the order has changed\n        //   let index = -1;\n        //   for (const entry of copy) {\n        //     index++;\n        //     const key = map.keyAt(index)!;\n        //     const [copyKey] = entry;\n        //     if (key !== copyKey) {\n        //       // order has changed!\n        //       return copy;\n        //     }\n        //   }\n        //   return map;\n        // });\n      });\n      observer.observe(collectionElement, {\n        childList: true,\n        subtree: true,\n      });\n      return () => {\n        observer.disconnect();\n      };\n    }, [collectionElement]);\n\n    return (\n      <CollectionContextProvider\n        scope={scope}\n        itemMap={itemMap}\n        setItemMap={setItemMap}\n        collectionRef={composeRefs}\n        collectionRefObject={ref}\n        collectionElement={collectionElement}\n      >\n        {children}\n      </CollectionContextProvider>\n    );\n  };\n\n  CollectionProviderImpl.displayName = PROVIDER_NAME + 'Impl';\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = name + 'CollectionSlot';\n\n  const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);\n  const CollectionSlot = React.forwardRef<CollectionElement, CollectionProps>(\n    (props, forwardedRef) => {\n      const { scope, children } = props;\n      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);\n      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n      return <CollectionSlotImpl ref={composedRefs}>{children}</CollectionSlotImpl>;\n    }\n  );\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = name + 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = ItemData & {\n    children: React.ReactNode;\n    scope: any;\n  };\n\n  const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { scope, children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const [element, setElement] = React.useState<ItemElement | null>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref, setElement);\n      const context = useCollectionContext(ITEM_SLOT_NAME, scope);\n\n      const { setItemMap } = context;\n\n      const itemDataRef = React.useRef(itemData);\n      if (!shallowEqual(itemDataRef.current, itemData)) {\n        itemDataRef.current = itemData;\n      }\n      const memoizedItemData = itemDataRef.current;\n\n      React.useEffect(() => {\n        const itemData = memoizedItemData;\n        setItemMap((map) => {\n          if (!element) {\n            return map;\n          }\n\n          if (!map.has(element)) {\n            map.set(element, { ...(itemData as unknown as ItemData), element });\n            return map.toSorted(sortByDocumentPosition);\n          }\n\n          return map\n            .set(element, { ...(itemData as unknown as ItemData), element })\n            .toSorted(sortByDocumentPosition);\n        });\n\n        return () => {\n          setItemMap((map) => {\n            if (!element || !map.has(element)) {\n              return map;\n            }\n            map.delete(element);\n            return new OrderedDict(map);\n          });\n        };\n      }, [element, memoizedItemData, setItemMap]);\n\n      return (\n        <CollectionItemSlotImpl {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs as any}>\n          {children}\n        </CollectionItemSlotImpl>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useInitCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useInitCollection() {\n    return React.useState<ItemMap<ItemElement, ItemData>>(new OrderedDict());\n  }\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection(scope: any) {\n    const { itemMap } = useCollectionContext(name + 'CollectionConsumer', scope);\n\n    return itemMap;\n  }\n\n  const functions = {\n    createCollectionScope,\n    useCollection,\n    useInitCollection,\n  };\n\n  return [\n    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },\n    functions,\n  ] as const;\n}\n\nexport { createCollection };\nexport type { CollectionProps };\n\nfunction shallowEqual(a: any, b: any) {\n  if (a === b) return true;\n  if (typeof a !== 'object' || typeof b !== 'object') return false;\n  if (a == null || b == null) return false;\n  const keysA = Object.keys(a);\n  const keysB = Object.keys(b);\n  if (keysA.length !== keysB.length) return false;\n  for (const key of keysA) {\n    if (!Object.prototype.hasOwnProperty.call(b, key)) return false;\n    if (a[key] !== b[key]) return false;\n  }\n  return true;\n}\n\nfunction isElementPreceding(a: Element, b: Element) {\n  return !!(b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING);\n}\n\nfunction sortByDocumentPosition<E extends HTMLElement, T extends BaseItemData>(\n  a: EntryOf<ItemMap<E, T>>,\n  b: EntryOf<ItemMap<E, T>>\n) {\n  return !a[1].element || !b[1].element\n    ? 0\n    : isElementPreceding(a[1].element, b[1].element)\n      ? -1\n      : 1;\n}\n\nfunction getChildListObserver(callback: () => void) {\n  const observer = new MutationObserver((mutationsList) => {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'childList') {\n        callback();\n        return;\n      }\n    }\n  });\n\n  return observer;\n}\n","// Not a real member because it shouldn't be accessible, but the super class\n// calls `set` which needs to read the instanciation state, so it can't be a\n// private member.\nconst __instanciated = new WeakMap<OrderedDict<any, any>, boolean>();\nexport class OrderedDict<K, V> extends Map<K, V> {\n  #keys: K[];\n\n  constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);\n  constructor(entries?: readonly (readonly [K, V])[] | null) {\n    super(entries);\n    this.#keys = [...super.keys()];\n    __instanciated.set(this, true);\n  }\n\n  set(key: K, value: V) {\n    if (__instanciated.get(this)) {\n      if (this.has(key)) {\n        this.#keys[this.#keys.indexOf(key)] = key;\n      } else {\n        this.#keys.push(key);\n      }\n    }\n    super.set(key, value);\n    return this;\n  }\n\n  insert(index: number, key: K, value: V) {\n    const has = this.has(key);\n    const length = this.#keys.length;\n    const relativeIndex = toSafeInteger(index);\n    let actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n    const safeIndex = actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n\n    if (safeIndex === this.size || (has && safeIndex === this.size - 1) || safeIndex === -1) {\n      this.set(key, value);\n      return this;\n    }\n\n    const size = this.size + (has ? 0 : 1);\n\n    // If you insert at, say, -2, without this bit you'd replace the\n    // second-to-last item and push the rest up one, which means the new item is\n    // 3rd to last. This isn't very intuitive; inserting at -2 is more like\n    // saying \"make this item the second to last\".\n    if (relativeIndex < 0) {\n      actualIndex++;\n    }\n\n    const keys = [...this.#keys];\n    let nextValue: V | undefined;\n    let shouldSkip = false;\n    for (let i = actualIndex; i < size; i++) {\n      if (actualIndex === i) {\n        let nextKey = keys[i]!;\n        if (keys[i] === key) {\n          nextKey = keys[i + 1]!;\n        }\n        if (has) {\n          // delete first to ensure that the item is moved to the end\n          this.delete(key);\n        }\n        nextValue = this.get(nextKey);\n        this.set(key, value);\n      } else {\n        if (!shouldSkip && keys[i - 1] === key) {\n          shouldSkip = true;\n        }\n        const currentKey = keys[shouldSkip ? i : i - 1]!;\n        const currentValue = nextValue!;\n        nextValue = this.get(currentKey);\n        this.delete(currentKey);\n        this.set(currentKey, currentValue);\n      }\n    }\n    return this;\n  }\n\n  with(index: number, key: K, value: V) {\n    const copy = new OrderedDict(this);\n    copy.insert(index, key, value);\n    return copy;\n  }\n\n  before(key: K) {\n    const index = this.#keys.indexOf(key) - 1;\n    if (index < 0) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position before the given key.\n   */\n  setBefore(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index, newKey, value);\n  }\n\n  after(key: K) {\n    let index = this.#keys.indexOf(key);\n    index = index === -1 || index === this.size - 1 ? -1 : index + 1;\n    if (index === -1) {\n      return undefined;\n    }\n    return this.entryAt(index);\n  }\n\n  /**\n   * Sets a new key-value pair at the position after the given key.\n   */\n  setAfter(key: K, newKey: K, value: V) {\n    const index = this.#keys.indexOf(key);\n    if (index === -1) {\n      return this;\n    }\n    return this.insert(index + 1, newKey, value);\n  }\n\n  first() {\n    return this.entryAt(0);\n  }\n\n  last() {\n    return this.entryAt(-1);\n  }\n\n  clear() {\n    this.#keys = [];\n    return super.clear();\n  }\n\n  delete(key: K) {\n    const deleted = super.delete(key);\n    if (deleted) {\n      this.#keys.splice(this.#keys.indexOf(key), 1);\n    }\n    return deleted;\n  }\n\n  deleteAt(index: number) {\n    const key = this.keyAt(index);\n    if (key !== undefined) {\n      return this.delete(key);\n    }\n    return false;\n  }\n\n  at(index: number) {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return this.get(key);\n    }\n  }\n\n  entryAt(index: number): [K, V] | undefined {\n    const key = at(this.#keys, index);\n    if (key !== undefined) {\n      return [key, this.get(key)!];\n    }\n  }\n\n  indexOf(key: K) {\n    return this.#keys.indexOf(key);\n  }\n\n  keyAt(index: number) {\n    return at(this.#keys, index);\n  }\n\n  from(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.at(dest);\n  }\n\n  keyFrom(key: K, offset: number) {\n    const index = this.indexOf(key);\n    if (index === -1) {\n      return undefined;\n    }\n    let dest = index + offset;\n    if (dest < 0) dest = 0;\n    if (dest >= this.size) dest = this.size - 1;\n    return this.keyAt(dest);\n  }\n\n  find(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return entry;\n      }\n      index++;\n    }\n    return undefined;\n  }\n\n  findIndex(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => boolean,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return index;\n      }\n      index++;\n    }\n    return -1;\n  }\n\n  filter<KK extends K, VV extends V>(\n    predicate: (entry: [K, V], index: number, dict: OrderedDict<K, V>) => entry is [KK, VV],\n    thisArg?: any\n  ): OrderedDict<KK, VV>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ): OrderedDict<K, V>;\n\n  filter(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    const entries: Array<[K, V]> = [];\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        entries.push(entry);\n      }\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  map<U>(\n    callbackfn: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => U,\n    thisArg?: any\n  ): OrderedDict<K, U> {\n    const entries: [K, U][] = [];\n    let index = 0;\n    for (const entry of this) {\n      entries.push([entry[0], Reflect.apply(callbackfn, thisArg, [entry, index, this])]);\n      index++;\n    }\n    return new OrderedDict(entries);\n  }\n\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduce(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduce<U>(\n    callbackfn: (\n      previousValue: U,\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduce<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let index = 0;\n    let accumulator = initialValue ?? this.at(0)!;\n    for (const entry of this) {\n      if (index === 0 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n      index++;\n    }\n    return accumulator;\n  }\n\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V]\n  ): [K, V];\n  reduceRight(\n    callbackfn: (\n      previousValue: [K, V],\n      currentEntry: [K, V],\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => [K, V],\n    initialValue: [K, V]\n  ): [K, V];\n  reduceRight<U>(\n    callbackfn: (\n      previousValue: [K, V],\n      currentValue: U,\n      currentIndex: number,\n      dictionary: OrderedDict<K, V>\n    ) => U,\n    initialValue: U\n  ): U;\n\n  reduceRight<U>(\n    ...args: [\n      (\n        previousValue: U,\n        currentEntry: [K, V],\n        currentIndex: number,\n        dictionary: OrderedDict<K, V>\n      ) => U,\n      U?,\n    ]\n  ) {\n    const [callbackfn, initialValue] = args;\n    let accumulator = initialValue ?? this.at(-1)!;\n    for (let index = this.size - 1; index >= 0; index--) {\n      const entry = this.at(index)!;\n      if (index === this.size - 1 && args.length === 1) {\n        accumulator = entry as any;\n      } else {\n        accumulator = Reflect.apply(callbackfn, this, [accumulator, entry, index, this]);\n      }\n    }\n    return accumulator;\n  }\n\n  toSorted(compareFn?: (a: [K, V], b: [K, V]) => number): OrderedDict<K, V> {\n    const entries = [...this.entries()].sort(compareFn);\n    return new OrderedDict(entries);\n  }\n\n  toReversed(): OrderedDict<K, V> {\n    const reversed = new OrderedDict<K, V>();\n    for (let index = this.size - 1; index >= 0; index--) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      reversed.set(key, element);\n    }\n    return reversed;\n  }\n\n  toSpliced(start: number, deleteCount?: number): OrderedDict<K, V>;\n  toSpliced(start: number, deleteCount: number, ...items: [K, V][]): OrderedDict<K, V>;\n\n  toSpliced(...args: [start: number, deleteCount: number, ...items: [K, V][]]) {\n    const entries = [...this.entries()];\n    entries.splice(...args);\n    return new OrderedDict(entries);\n  }\n\n  slice(start?: number, end?: number) {\n    const result = new OrderedDict<K, V>();\n    let stop = this.size - 1;\n\n    if (start === undefined) {\n      return result;\n    }\n\n    if (start < 0) {\n      start = start + this.size;\n    }\n\n    if (end !== undefined && end > 0) {\n      stop = end - 1;\n    }\n\n    for (let index = start; index <= stop; index++) {\n      const key = this.keyAt(index)!;\n      const element = this.get(key)!;\n      result.set(key, element);\n    }\n    return result;\n  }\n\n  every(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (!Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n\n  some(\n    predicate: (entry: [K, V], index: number, dictionary: OrderedDict<K, V>) => unknown,\n    thisArg?: any\n  ) {\n    let index = 0;\n    for (const entry of this) {\n      if (Reflect.apply(predicate, thisArg, [entry, index, this])) {\n        return true;\n      }\n      index++;\n    }\n    return false;\n  }\n}\n\nexport type KeyOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<infer K, any> ? K : never;\nexport type ValueOf<D extends OrderedDict<any, any>> =\n  D extends OrderedDict<any, infer V> ? V : never;\nexport type EntryOf<D extends OrderedDict<any, any>> = [KeyOf<D>, ValueOf<D>];\nexport type KeyFrom<E extends EntryOf<any>> = E[0];\nexport type ValueFrom<E extends EntryOf<any>> = E[1];\n\nfunction at<T>(array: ArrayLike<T>, index: number): T | undefined {\n  if ('at' in Array.prototype) {\n    return Array.prototype.at.call(array, index);\n  }\n  const actualIndex = toSafeIndex(array, index);\n  return actualIndex === -1 ? undefined : array[actualIndex];\n}\n\nfunction toSafeIndex(array: ArrayLike<any>, index: number) {\n  const length = array.length;\n  const relativeIndex = toSafeInteger(index);\n  const actualIndex = relativeIndex >= 0 ? relativeIndex : length + relativeIndex;\n  return actualIndex < 0 || actualIndex >= length ? -1 : actualIndex;\n}\n\nfunction toSafeInteger(number: number) {\n  // eslint-disable-next-line no-self-compare\n  return number !== number || number === 0 ? 0 : Math.trunc(number);\n}\n","// packages/react/direction/src/direction.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar DirectionContext = React.createContext(void 0);\nvar DirectionProvider = (props) => {\n  const { dir, children } = props;\n  return /* @__PURE__ */ jsx(DirectionContext.Provider, { value: dir, children });\n};\nfunction useDirection(localDir) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || \"ltr\";\n}\nvar Provider = DirectionProvider;\nexport {\n  DirectionProvider,\n  Provider,\n  useDirection\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/core/number/src/number.ts\nfunction clamp(value, [min, max]) {\n  return Math.min(max, Math.max(min, value));\n}\nexport {\n  clamp\n};\n//# sourceMappingURL=index.mjs.map\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== getSideAxis(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, arrow as arrow$1, autoPlacement as autoPlacement$1, detectOverflow as detectOverflow$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle as getComputedStyle$1, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle$1(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll) {\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Safety check: ensure the scrollbar space is reasonable in case this\n// calculation is affected by unusual styles.\n// Most scrollbars leave 15-18px of space.\nconst SCROLLBAR_MAX = 25;\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  const windowScrollbarX = getWindowScrollBarX(html);\n  // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the\n  // visual width of the <html> but this is not considered in the size\n  // of `html.clientWidth`.\n  if (windowScrollbarX <= 0) {\n    const doc = html.ownerDocument;\n    const body = doc.body;\n    const bodyStyles = getComputedStyle(body);\n    const bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;\n    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);\n    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {\n      width -= clippingStableScrollbarWidth;\n    }\n  } else if (windowScrollbarX <= SCROLLBAR_MAX) {\n    // If the <body> scrollbar is on the left, the width needs to be extended\n    // by the scrollbar amount so there isn't extra space on the right.\n    width += windowScrollbarX;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle$1(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import { computePosition, arrow as arrow$2, autoPlacement as autoPlacement$1, flip as flip$1, hide as hide$1, inline as inline$1, limitShift as limitShift$1, offset as offset$1, shift as shift$1, size as size$1 } from '@floating-ui/dom';\nexport { autoUpdate, computePosition, detectOverflow, getOverflowAncestors, platform } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\nvar isClient = typeof document !== 'undefined';\n\nvar noop = function noop() {};\nvar index = isClient ? useLayoutEffect : noop;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const openRef = useLatestRef(open);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // `isPositioned` will be `false` initially on the next open, avoid\n        // setting it to `true` when `open === false` (must be specified).\n        isPositioned: openRef.current !== false\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow$1 = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$2({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return arrow$2({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = (options, deps) => ({\n  ...offset$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = (options, deps) => ({\n  ...shift$1(options),\n  options: [options, deps]\n});\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = (options, deps) => ({\n  ...limitShift$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = (options, deps) => ({\n  ...flip$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = (options, deps) => ({\n  ...size$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = (options, deps) => ({\n  ...autoPlacement$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = (options, deps) => ({\n  ...hide$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = (options, deps) => ({\n  ...inline$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = (options, deps) => ({\n  ...arrow$1(options),\n  options: [options, deps]\n});\n\nexport { arrow, autoPlacement, flip, hide, inline, limitShift, offset, shift, size, useFloating };\n","// src/arrow.tsx\nimport * as React from \"react\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx } from \"react/jsx-runtime\";\nvar NAME = \"Arrow\";\nvar Arrow = React.forwardRef((props, forwardedRef) => {\n  const { children, width = 10, height = 5, ...arrowProps } = props;\n  return /* @__PURE__ */ jsx(\n    Primitive.svg,\n    {\n      ...arrowProps,\n      ref: forwardedRef,\n      width,\n      height,\n      viewBox: \"0 0 30 10\",\n      preserveAspectRatio: \"none\",\n      children: props.asChild ? children : /* @__PURE__ */ jsx(\"polygon\", { points: \"0,0 30,0 15,10\" })\n    }\n  );\n});\nArrow.displayName = NAME;\nvar Root = Arrow;\nexport {\n  Arrow,\n  Root\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/react/use-size/src/use-size.tsx\nimport * as React from \"react\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nfunction useSize(element) {\n  const [size, setSize] = React.useState(void 0);\n  useLayoutEffect(() => {\n    if (element) {\n      setSize({ width: element.offsetWidth, height: element.offsetHeight });\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n        if (!entries.length) {\n          return;\n        }\n        const entry = entries[0];\n        let width;\n        let height;\n        if (\"borderBoxSize\" in entry) {\n          const borderSizeEntry = entry[\"borderBoxSize\"];\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize[\"inlineSize\"];\n          height = borderSize[\"blockSize\"];\n        } else {\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n        setSize({ width, height });\n      });\n      resizeObserver.observe(element, { box: \"border-box\" });\n      return () => resizeObserver.unobserve(element);\n    } else {\n      setSize(void 0);\n    }\n  }, [element]);\n  return size;\n}\nexport {\n  useSize\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport {\n  useFloating,\n  autoUpdate,\n  offset,\n  shift,\n  limitShift,\n  hide,\n  arrow as floatingUIarrow,\n  flip,\n  size,\n} from '@floating-ui/react-dom';\nimport * as ArrowPrimitive from '@radix-ui/react-arrow';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useSize } from '@radix-ui/react-use-size';\n\nimport type { Placement, Middleware } from '@floating-ui/react-dom';\nimport type { Scope } from '@radix-ui/react-context';\nimport type { Measurable } from '@radix-ui/rect';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\n\n/* -------------------------------------------------------------------------------------------------\n * Popper\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_NAME = 'Popper';\n\ntype ScopedProps<P> = P & { __scopePopper?: Scope };\nconst [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\n\ntype PopperContextValue = {\n  anchor: Measurable | null;\n  onAnchorChange(anchor: Measurable | null): void;\n};\nconst [PopperProvider, usePopperContext] = createPopperContext<PopperContextValue>(POPPER_NAME);\n\ninterface PopperProps {\n  children?: React.ReactNode;\n}\nconst Popper: React.FC<PopperProps> = (props: ScopedProps<PopperProps>) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState<Measurable | null>(null);\n  return (\n    <PopperProvider scope={__scopePopper} anchor={anchor} onAnchorChange={setAnchor}>\n      {children}\n    </PopperProvider>\n  );\n};\n\nPopper.displayName = POPPER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'PopperAnchor';\n\ntype PopperAnchorElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PopperAnchorProps extends PrimitiveDivProps {\n  virtualRef?: React.RefObject<Measurable>;\n}\n\nconst PopperAnchor = React.forwardRef<PopperAnchorElement, PopperAnchorProps>(\n  (props: ScopedProps<PopperAnchorProps>, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef<PopperAnchorElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    const anchorRef = React.useRef<Measurable | null>(null);\n    React.useEffect(() => {\n      const previousAnchor = anchorRef.current;\n      anchorRef.current = virtualRef?.current || ref.current;\n      if (previousAnchor !== anchorRef.current) {\n        // Consumer can anchor the popper to something that isn't\n        // a DOM node e.g. pointer position, so we override the\n        // `anchorRef` with their virtual ref in this case.\n        context.onAnchorChange(anchorRef.current);\n      }\n    });\n\n    return virtualRef ? null : <Primitive.div {...anchorProps} ref={composedRefs} />;\n  }\n);\n\nPopperAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'PopperContent';\n\ntype PopperContentContextValue = {\n  placedSide: Side;\n  onArrowChange(arrow: HTMLSpanElement | null): void;\n  arrowX?: number;\n  arrowY?: number;\n  shouldHideArrow: boolean;\n};\n\nconst [PopperContentProvider, useContentContext] =\n  createPopperContext<PopperContentContextValue>(CONTENT_NAME);\n\ntype Boundary = Element | null;\n\ntype PopperContentElement = React.ComponentRef<typeof Primitive.div>;\ninterface PopperContentProps extends PrimitiveDivProps {\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  arrowPadding?: number;\n  avoidCollisions?: boolean;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  sticky?: 'partial' | 'always';\n  hideWhenDetached?: boolean;\n  updatePositionStrategy?: 'optimized' | 'always';\n  onPlaced?: () => void;\n}\n\nconst PopperContent = React.forwardRef<PopperContentElement, PopperContentProps>(\n  (props: ScopedProps<PopperContentProps>, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = 'bottom',\n      sideOffset = 0,\n      align = 'center',\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = 'partial',\n      hideWhenDetached = false,\n      updatePositionStrategy = 'optimized',\n      onPlaced,\n      ...contentProps\n    } = props;\n\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n\n    const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\n    const arrowSize = useSize(arrow);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n\n    const desiredPlacement = (side + (align !== 'center' ? '-' + align : '')) as Placement;\n\n    const collisionPadding =\n      typeof collisionPaddingProp === 'number'\n        ? collisionPaddingProp\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries,\n    };\n\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: 'fixed',\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === 'always',\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor,\n      },\n      middleware: [\n        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions &&\n          shift({\n            mainAxis: true,\n            crossAxis: false,\n            limiter: sticky === 'partial' ? limitShift() : undefined,\n            ...detectOverflowOptions,\n          }),\n        avoidCollisions && flip({ ...detectOverflowOptions }),\n        size({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`);\n            contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`);\n            contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`);\n            contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`);\n          },\n        }),\n        arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide({ strategy: 'referenceHidden', ...detectOverflowOptions }),\n      ],\n    });\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n\n    const [contentZIndex, setContentZIndex] = React.useState<string>();\n    useLayoutEffect(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n\n    return (\n      <div\n        ref={refs.setFloating}\n        data-radix-popper-content-wrapper=\"\"\n        style={{\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n          minWidth: 'max-content',\n          zIndex: contentZIndex,\n          ['--radix-popper-transform-origin' as any]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y,\n          ].join(' '),\n\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...(middlewareData.hide?.referenceHidden && {\n            visibility: 'hidden',\n            pointerEvents: 'none',\n          }),\n        }}\n        // Floating UI interally calculates logical alignment based the `dir` attribute on\n        // the reference/floating node, we must add this attribute here to ensure\n        // this is calculated when portalled as well as inline.\n        dir={props.dir}\n      >\n        <PopperContentProvider\n          scope={__scopePopper}\n          placedSide={placedSide}\n          onArrowChange={setArrow}\n          arrowX={arrowX}\n          arrowY={arrowY}\n          shouldHideArrow={cannotCenterArrow}\n        >\n          <Primitive.div\n            data-side={placedSide}\n            data-align={placedAlign}\n            {...contentProps}\n            ref={composedRefs}\n            style={{\n              ...contentProps.style,\n              // if the PopperContent hasn't been placed yet (not all measurements done)\n              // we prevent animations so that users's animation don't kick in too early referring wrong sides\n              animation: !isPositioned ? 'none' : undefined,\n            }}\n          />\n        </PopperContentProvider>\n      </div>\n    );\n  }\n);\n\nPopperContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'PopperArrow';\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\ntype PopperArrowElement = React.ComponentRef<typeof ArrowPrimitive.Root>;\ntype ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;\ninterface PopperArrowProps extends ArrowProps {}\n\nconst PopperArrow = React.forwardRef<PopperArrowElement, PopperArrowProps>(function PopperArrow(\n  props: ScopedProps<PopperArrowProps>,\n  forwardedRef\n) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    <span\n      ref={contentContext.onArrowChange}\n      style={{\n        position: 'absolute',\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: '',\n          right: '0 0',\n          bottom: 'center 0',\n          left: '100% 0',\n        }[contentContext.placedSide],\n        transform: {\n          top: 'translateY(100%)',\n          right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n          bottom: `rotate(180deg)`,\n          left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? 'hidden' : undefined,\n      }}\n    >\n      <ArrowPrimitive.Root\n        {...arrowProps}\n        ref={forwardedRef}\n        style={{\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: 'block',\n        }}\n      />\n    </span>\n  );\n});\n\nPopperArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nconst transformOrigin = (options: { arrowWidth: number; arrowHeight: number }): Middleware => ({\n  name: 'transformOrigin',\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[placedAlign];\n\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n\n    let x = '';\n    let y = '';\n\n    if (placedSide === 'bottom') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === 'top') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === 'right') {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === 'left') {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  },\n});\n\nfunction getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-');\n  return [side as Side, align as Align] as const;\n}\n\nconst Root = Popper;\nconst Anchor = PopperAnchor;\nconst Content = PopperContent;\nconst Arrow = PopperArrow;\n\nexport {\n  createPopperScope,\n  //\n  Popper,\n  PopperAnchor,\n  PopperContent,\n  PopperArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Arrow,\n  //\n  SIDE_OPTIONS,\n  ALIGN_OPTIONS,\n};\nexport type { PopperProps, PopperAnchorProps, PopperContentProps, PopperArrowProps };\n","// packages/react/use-previous/src/use-previous.tsx\nimport * as React from \"react\";\nfunction usePrevious(value) {\n  const ref = React.useRef({ value, previous: value });\n  return React.useMemo(() => {\n    if (ref.current.value !== value) {\n      ref.current.previous = ref.current.value;\n      ref.current.value = value;\n    }\n    return ref.current.previous;\n  }, [value]);\n}\nexport {\n  usePrevious\n};\n//# sourceMappingURL=index.mjs.map\n","// src/visually-hidden.tsx\nimport * as React from \"react\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx } from \"react/jsx-runtime\";\nvar VISUALLY_HIDDEN_STYLES = Object.freeze({\n  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss\n  position: \"absolute\",\n  border: 0,\n  width: 1,\n  height: 1,\n  padding: 0,\n  margin: -1,\n  overflow: \"hidden\",\n  clip: \"rect(0, 0, 0, 0)\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n});\nvar NAME = \"VisuallyHidden\";\nvar VisuallyHidden = React.forwardRef(\n  (props, forwardedRef) => {\n    return /* @__PURE__ */ jsx(\n      Primitive.span,\n      {\n        ...props,\n        ref: forwardedRef,\n        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }\n      }\n    );\n  }\n);\nVisuallyHidden.displayName = NAME;\nvar Root = VisuallyHidden;\nexport {\n  Root,\n  VISUALLY_HIDDEN_STYLES,\n  VisuallyHidden\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createSlot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { VISUALLY_HIDDEN_STYLES } from '@radix-ui/react-visually-hidden';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst OPEN_KEYS = [' ', 'Enter', 'ArrowUp', 'ArrowDown'];\nconst SELECTION_KEYS = [' ', 'Enter'];\n\n/* -------------------------------------------------------------------------------------------------\n * Select\n * -----------------------------------------------------------------------------------------------*/\n\nconst SELECT_NAME = 'Select';\n\ntype ItemData = { value: string; disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  SelectItemElement,\n  ItemData\n>(SELECT_NAME);\n\ntype ScopedProps<P> = P & { __scopeSelect?: Scope };\nconst [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [\n  createCollectionScope,\n  createPopperScope,\n]);\nconst usePopperScope = createPopperScope();\n\ntype SelectContextValue = {\n  trigger: SelectTriggerElement | null;\n  onTriggerChange(node: SelectTriggerElement | null): void;\n  valueNode: SelectValueElement | null;\n  onValueNodeChange(node: SelectValueElement): void;\n  valueNodeHasChildren: boolean;\n  onValueNodeHasChildrenChange(hasChildren: boolean): void;\n  contentId: string;\n  value: string | undefined;\n  onValueChange(value: string): void;\n  open: boolean;\n  required?: boolean;\n  onOpenChange(open: boolean): void;\n  dir: SelectProps['dir'];\n  triggerPointerDownPosRef: React.MutableRefObject<{ x: number; y: number } | null>;\n  disabled?: boolean;\n};\n\nconst [SelectProvider, useSelectContext] = createSelectContext<SelectContextValue>(SELECT_NAME);\n\ntype NativeOption = React.ReactElement<React.ComponentProps<'option'>>;\n\ntype SelectNativeOptionsContextValue = {\n  onNativeOptionAdd(option: NativeOption): void;\n  onNativeOptionRemove(option: NativeOption): void;\n};\nconst [SelectNativeOptionsProvider, useSelectNativeOptionsContext] =\n  createSelectContext<SelectNativeOptionsContextValue>(SELECT_NAME);\n\ninterface ControlledClearableSelectProps {\n  value: string | undefined;\n  defaultValue?: never;\n  onValueChange: (value: string | undefined) => void;\n}\n\ninterface ControlledUnclearableSelectProps {\n  value: string;\n  defaultValue?: never;\n  onValueChange: (value: string) => void;\n}\n\ninterface UncontrolledSelectProps {\n  value?: never;\n  defaultValue?: string;\n  onValueChange?: {\n    (value: string): void;\n    (value: string | undefined): void;\n  };\n}\n\ntype SelectControlProps =\n  | ControlledClearableSelectProps\n  | ControlledUnclearableSelectProps\n  | UncontrolledSelectProps;\n\ninterface SelectSharedProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  name?: string;\n  autoComplete?: string;\n  disabled?: boolean;\n  required?: boolean;\n  form?: string;\n}\n\n// TODO: Should improve typing somewhat, but this would be a breaking change.\n// Consider using in the next major version (along with some testing to be sure\n// it works as expected and doesn't cause problems)\ntype _FutureSelectProps = SelectSharedProps & SelectControlProps;\n\ntype SelectProps = SelectSharedProps & {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?(value: string): void;\n};\n\nconst Select: React.FC<SelectProps> = (props: ScopedProps<SelectProps>) => {\n  const {\n    __scopeSelect,\n    children,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    value: valueProp,\n    defaultValue,\n    onValueChange,\n    dir,\n    name,\n    autoComplete,\n    disabled,\n    required,\n    form,\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n  const [trigger, setTrigger] = React.useState<SelectTriggerElement | null>(null);\n  const [valueNode, setValueNode] = React.useState<SelectValueElement | null>(null);\n  const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);\n  const direction = useDirection(dir);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: SELECT_NAME,\n  });\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange as any,\n    caller: SELECT_NAME,\n  });\n  const triggerPointerDownPosRef = React.useRef<{ x: number; y: number } | null>(null);\n\n  // We set this to true by default so that events bubble to forms without JS (SSR)\n  const isFormControl = trigger ? form || !!trigger.closest('form') : true;\n  const [nativeOptionsSet, setNativeOptionsSet] = React.useState(new Set<NativeOption>());\n\n  // The native `select` only associates the correct default value if the corresponding\n  // `option` is rendered as a child **at the same time** as itself.\n  // Because it might take a few renders for our items to gather the information to build\n  // the native `option`(s), we generate a key on the `select` to make sure React re-builds it\n  // each time the options change.\n  const nativeSelectKey = Array.from(nativeOptionsSet)\n    .map((option) => option.props.value)\n    .join(';');\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <SelectProvider\n        required={required}\n        scope={__scopeSelect}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        valueNode={valueNode}\n        onValueNodeChange={setValueNode}\n        valueNodeHasChildren={valueNodeHasChildren}\n        onValueNodeHasChildrenChange={setValueNodeHasChildren}\n        contentId={useId()}\n        value={value}\n        onValueChange={setValue}\n        open={open}\n        onOpenChange={setOpen}\n        dir={direction}\n        triggerPointerDownPosRef={triggerPointerDownPosRef}\n        disabled={disabled}\n      >\n        <Collection.Provider scope={__scopeSelect}>\n          <SelectNativeOptionsProvider\n            scope={props.__scopeSelect}\n            onNativeOptionAdd={React.useCallback((option) => {\n              setNativeOptionsSet((prev) => new Set(prev).add(option));\n            }, [])}\n            onNativeOptionRemove={React.useCallback((option) => {\n              setNativeOptionsSet((prev) => {\n                const optionsSet = new Set(prev);\n                optionsSet.delete(option);\n                return optionsSet;\n              });\n            }, [])}\n          >\n            {children}\n          </SelectNativeOptionsProvider>\n        </Collection.Provider>\n\n        {isFormControl ? (\n          <SelectBubbleInput\n            key={nativeSelectKey}\n            aria-hidden\n            required={required}\n            tabIndex={-1}\n            name={name}\n            autoComplete={autoComplete}\n            value={value}\n            // enable form autofill\n            onChange={(event) => setValue(event.target.value)}\n            disabled={disabled}\n            form={form}\n          >\n            {value === undefined ? <option value=\"\" /> : null}\n            {Array.from(nativeOptionsSet)}\n          </SelectBubbleInput>\n        ) : null}\n      </SelectProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nSelect.displayName = SELECT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'SelectTrigger';\n\ntype SelectTriggerElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface SelectTriggerProps extends PrimitiveButtonProps {}\n\nconst SelectTrigger = React.forwardRef<SelectTriggerElement, SelectTriggerProps>(\n  (props: ScopedProps<SelectTriggerProps>, forwardedRef) => {\n    const { __scopeSelect, disabled = false, ...triggerProps } = props;\n    const popperScope = usePopperScope(__scopeSelect);\n    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);\n    const isDisabled = context.disabled || disabled;\n    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);\n    const getItems = useCollection(__scopeSelect);\n    const pointerTypeRef = React.useRef<React.PointerEvent['pointerType']>('touch');\n\n    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {\n      const enabledItems = getItems().filter((item) => !item.disabled);\n      const currentItem = enabledItems.find((item) => item.value === context.value);\n      const nextItem = findNextItem(enabledItems, search, currentItem);\n      if (nextItem !== undefined) {\n        context.onValueChange(nextItem.value);\n      }\n    });\n\n    const handleOpen = (pointerEvent?: React.MouseEvent | React.PointerEvent) => {\n      if (!isDisabled) {\n        context.onOpenChange(true);\n        // reset typeahead when we open\n        resetTypeahead();\n      }\n\n      if (pointerEvent) {\n        context.triggerPointerDownPosRef.current = {\n          x: Math.round(pointerEvent.pageX),\n          y: Math.round(pointerEvent.pageY),\n        };\n      }\n    };\n\n    return (\n      <PopperPrimitive.Anchor asChild {...popperScope}>\n        <Primitive.button\n          type=\"button\"\n          role=\"combobox\"\n          aria-controls={context.contentId}\n          aria-expanded={context.open}\n          aria-required={context.required}\n          aria-autocomplete=\"none\"\n          dir={context.dir}\n          data-state={context.open ? 'open' : 'closed'}\n          disabled={isDisabled}\n          data-disabled={isDisabled ? '' : undefined}\n          data-placeholder={shouldShowPlaceholder(context.value) ? '' : undefined}\n          {...triggerProps}\n          ref={composedRefs}\n          // Enable compatibility with native label or custom `Label` \"click\" for Safari:\n          onClick={composeEventHandlers(triggerProps.onClick, (event) => {\n            // Whilst browsers generally have no issue focusing the trigger when clicking\n            // on a label, Safari seems to struggle with the fact that there's no `onClick`.\n            // We force `focus` in this case. Note: this doesn't create any other side-effect\n            // because we are preventing default in `onPointerDown` so effectively\n            // this only runs for a label \"click\"\n            event.currentTarget.focus();\n\n            // Open on click when using a touch or pen device\n            if (pointerTypeRef.current !== 'mouse') {\n              handleOpen(event);\n            }\n          })}\n          onPointerDown={composeEventHandlers(triggerProps.onPointerDown, (event) => {\n            pointerTypeRef.current = event.pointerType;\n\n            // prevent implicit pointer capture\n            // https://www.w3.org/TR/pointerevents3/#implicit-pointer-capture\n            const target = event.target as HTMLElement;\n            if (target.hasPointerCapture(event.pointerId)) {\n              target.releasePointerCapture(event.pointerId);\n            }\n\n            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n            // but not when the control key is pressed (avoiding MacOS right click); also not for touch\n            // devices because that would open the menu on scroll. (pen devices behave as touch on iOS).\n            if (event.button === 0 && event.ctrlKey === false && event.pointerType === 'mouse') {\n              handleOpen(event);\n              // prevent trigger from stealing focus from the active item after opening.\n              event.preventDefault();\n            }\n          })}\n          onKeyDown={composeEventHandlers(triggerProps.onKeyDown, (event) => {\n            const isTypingAhead = searchRef.current !== '';\n            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n            if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n            if (isTypingAhead && event.key === ' ') return;\n            if (OPEN_KEYS.includes(event.key)) {\n              handleOpen();\n              event.preventDefault();\n            }\n          })}\n        />\n      </PopperPrimitive.Anchor>\n    );\n  }\n);\n\nSelectTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectValue\n * -----------------------------------------------------------------------------------------------*/\n\nconst VALUE_NAME = 'SelectValue';\n\ntype SelectValueElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SelectValueProps extends Omit<PrimitiveSpanProps, 'placeholder'> {\n  placeholder?: React.ReactNode;\n}\n\nconst SelectValue = React.forwardRef<SelectValueElement, SelectValueProps>(\n  (props: ScopedProps<SelectValueProps>, forwardedRef) => {\n    // We ignore `className` and `style` as this part shouldn't be styled.\n    const { __scopeSelect, className, style, children, placeholder = '', ...valueProps } = props;\n    const context = useSelectContext(VALUE_NAME, __scopeSelect);\n    const { onValueNodeHasChildrenChange } = context;\n    const hasChildren = children !== undefined;\n    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);\n\n    useLayoutEffect(() => {\n      onValueNodeHasChildrenChange(hasChildren);\n    }, [onValueNodeHasChildrenChange, hasChildren]);\n\n    return (\n      <Primitive.span\n        {...valueProps}\n        ref={composedRefs}\n        // we don't want events from the portalled `SelectValue` children to bubble\n        // through the item they came from\n        style={{ pointerEvents: 'none' }}\n      >\n        {shouldShowPlaceholder(context.value) ? <>{placeholder}</> : children}\n      </Primitive.span>\n    );\n  }\n);\n\nSelectValue.displayName = VALUE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectIcon\n * -----------------------------------------------------------------------------------------------*/\n\nconst ICON_NAME = 'SelectIcon';\n\ntype SelectIconElement = React.ComponentRef<typeof Primitive.span>;\ninterface SelectIconProps extends PrimitiveSpanProps {}\n\nconst SelectIcon = React.forwardRef<SelectIconElement, SelectIconProps>(\n  (props: ScopedProps<SelectIconProps>, forwardedRef) => {\n    const { __scopeSelect, children, ...iconProps } = props;\n    return (\n      <Primitive.span aria-hidden {...iconProps} ref={forwardedRef}>\n        {children || '▼'}\n      </Primitive.span>\n    );\n  }\n);\n\nSelectIcon.displayName = ICON_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'SelectPortal';\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface SelectPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n}\n\nconst SelectPortal: React.FC<SelectPortalProps> = (props: ScopedProps<SelectPortalProps>) => {\n  return <PortalPrimitive asChild {...props} />;\n};\n\nSelectPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'SelectContent';\n\ntype SelectContentElement = SelectContentImplElement;\ninterface SelectContentProps extends SelectContentImplProps {}\n\nconst SelectContent = React.forwardRef<SelectContentElement, SelectContentProps>(\n  (props: ScopedProps<SelectContentProps>, forwardedRef) => {\n    const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);\n    const [fragment, setFragment] = React.useState<DocumentFragment>();\n\n    // setting the fragment in `useLayoutEffect` as `DocumentFragment` doesn't exist on the server\n    useLayoutEffect(() => {\n      setFragment(new DocumentFragment());\n    }, []);\n\n    if (!context.open) {\n      const frag = fragment as Element | undefined;\n      return frag\n        ? ReactDOM.createPortal(\n            <SelectContentProvider scope={props.__scopeSelect}>\n              <Collection.Slot scope={props.__scopeSelect}>\n                <div>{props.children}</div>\n              </Collection.Slot>\n            </SelectContentProvider>,\n            frag\n          )\n        : null;\n    }\n\n    return <SelectContentImpl {...props} ref={forwardedRef} />;\n  }\n);\n\nSelectContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectContentImpl\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_MARGIN = 10;\n\ntype SelectContentContextValue = {\n  content?: SelectContentElement | null;\n  viewport?: SelectViewportElement | null;\n  onViewportChange?: (node: SelectViewportElement | null) => void;\n  itemRefCallback?: (node: SelectItemElement | null, value: string, disabled: boolean) => void;\n  selectedItem?: SelectItemElement | null;\n  onItemLeave?: () => void;\n  itemTextRefCallback?: (\n    node: SelectItemTextElement | null,\n    value: string,\n    disabled: boolean\n  ) => void;\n  focusSelectedItem?: () => void;\n  selectedItemText?: SelectItemTextElement | null;\n  position?: SelectContentProps['position'];\n  isPositioned?: boolean;\n  searchRef?: React.RefObject<string>;\n};\n\nconst [SelectContentProvider, useSelectContentContext] =\n  createSelectContext<SelectContentContextValue>(CONTENT_NAME);\n\nconst CONTENT_IMPL_NAME = 'SelectContentImpl';\n\ntype SelectContentImplElement = SelectPopperPositionElement | SelectItemAlignedPositionElement;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\n\ntype SelectPopperPrivateProps = { onPlaced?: PopperContentProps['onPlaced'] };\n\ninterface SelectContentImplProps\n  extends Omit<SelectPopperPositionProps, keyof SelectPopperPrivateProps>,\n    Omit<SelectItemAlignedPositionProps, keyof SelectPopperPrivateProps> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n\n  position?: 'item-aligned' | 'popper';\n}\n\nconst Slot = createSlot('SelectContent.RemoveScroll');\n\nconst SelectContentImpl = React.forwardRef<SelectContentImplElement, SelectContentImplProps>(\n  (props: ScopedProps<SelectContentImplProps>, forwardedRef) => {\n    const {\n      __scopeSelect,\n      position = 'item-aligned',\n      onCloseAutoFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      //\n      // PopperContent props\n      side,\n      sideOffset,\n      align,\n      alignOffset,\n      arrowPadding,\n      collisionBoundary,\n      collisionPadding,\n      sticky,\n      hideWhenDetached,\n      avoidCollisions,\n      //\n      ...contentProps\n    } = props;\n    const context = useSelectContext(CONTENT_NAME, __scopeSelect);\n    const [content, setContent] = React.useState<SelectContentImplElement | null>(null);\n    const [viewport, setViewport] = React.useState<SelectViewportElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n    const [selectedItem, setSelectedItem] = React.useState<SelectItemElement | null>(null);\n    const [selectedItemText, setSelectedItemText] = React.useState<SelectItemTextElement | null>(\n      null\n    );\n    const getItems = useCollection(__scopeSelect);\n    const [isPositioned, setIsPositioned] = React.useState(false);\n    const firstValidItemFoundRef = React.useRef(false);\n\n    // aria-hide everything except the content (better supported equivalent to setting aria-modal)\n    React.useEffect(() => {\n      if (content) return hideOthers(content);\n    }, [content]);\n\n    // Make sure the whole tree has focus guards as our `Select` may be\n    // the last element in the DOM (because of the `Portal`)\n    useFocusGuards();\n\n    const focusFirst = React.useCallback(\n      (candidates: Array<HTMLElement | null>) => {\n        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);\n        const [lastItem] = restItems.slice(-1);\n\n        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n        for (const candidate of candidates) {\n          // if focus is already where we want to go, we don't want to keep going through the candidates\n          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n          candidate?.scrollIntoView({ block: 'nearest' });\n          // viewport might have padding so scroll to its edges when focusing first/last items.\n          if (candidate === firstItem && viewport) viewport.scrollTop = 0;\n          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;\n          candidate?.focus();\n          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n        }\n      },\n      [getItems, viewport]\n    );\n\n    const focusSelectedItem = React.useCallback(\n      () => focusFirst([selectedItem, content]),\n      [focusFirst, selectedItem, content]\n    );\n\n    // Since this is not dependent on layout, we want to ensure this runs at the same time as\n    // other effects across components. Hence why we don't call `focusSelectedItem` inside `position`.\n    React.useEffect(() => {\n      if (isPositioned) {\n        focusSelectedItem();\n      }\n    }, [isPositioned, focusSelectedItem]);\n\n    // prevent selecting items on `pointerup` in some cases after opening from `pointerdown`\n    // and close on `pointerup` outside.\n    const { onOpenChange, triggerPointerDownPosRef } = context;\n    React.useEffect(() => {\n      if (content) {\n        let pointerMoveDelta = { x: 0, y: 0 };\n\n        const handlePointerMove = (event: PointerEvent) => {\n          pointerMoveDelta = {\n            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),\n            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0)),\n          };\n        };\n        const handlePointerUp = (event: PointerEvent) => {\n          // If the pointer hasn't moved by a certain threshold then we prevent selecting item on `pointerup`.\n          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {\n            event.preventDefault();\n          } else {\n            // otherwise, if the event was outside the content, close.\n            if (!content.contains(event.target as HTMLElement)) {\n              onOpenChange(false);\n            }\n          }\n          document.removeEventListener('pointermove', handlePointerMove);\n          triggerPointerDownPosRef.current = null;\n        };\n\n        if (triggerPointerDownPosRef.current !== null) {\n          document.addEventListener('pointermove', handlePointerMove);\n          document.addEventListener('pointerup', handlePointerUp, { capture: true, once: true });\n        }\n\n        return () => {\n          document.removeEventListener('pointermove', handlePointerMove);\n          document.removeEventListener('pointerup', handlePointerUp, { capture: true });\n        };\n      }\n    }, [content, onOpenChange, triggerPointerDownPosRef]);\n\n    React.useEffect(() => {\n      const close = () => onOpenChange(false);\n      window.addEventListener('blur', close);\n      window.addEventListener('resize', close);\n      return () => {\n        window.removeEventListener('blur', close);\n        window.removeEventListener('resize', close);\n      };\n    }, [onOpenChange]);\n\n    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {\n      const enabledItems = getItems().filter((item) => !item.disabled);\n      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);\n      const nextItem = findNextItem(enabledItems, search, currentItem);\n      if (nextItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (nextItem.ref.current as HTMLElement).focus());\n      }\n    });\n\n    const itemRefCallback = React.useCallback(\n      (node: SelectItemElement | null, value: string, disabled: boolean) => {\n        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n        const isSelectedItem = context.value !== undefined && context.value === value;\n        if (isSelectedItem || isFirstValidItem) {\n          setSelectedItem(node);\n          if (isFirstValidItem) firstValidItemFoundRef.current = true;\n        }\n      },\n      [context.value]\n    );\n    const handleItemLeave = React.useCallback(() => content?.focus(), [content]);\n    const itemTextRefCallback = React.useCallback(\n      (node: SelectItemTextElement | null, value: string, disabled: boolean) => {\n        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n        const isSelectedItem = context.value !== undefined && context.value === value;\n        if (isSelectedItem || isFirstValidItem) {\n          setSelectedItemText(node);\n        }\n      },\n      [context.value]\n    );\n\n    const SelectPosition = position === 'popper' ? SelectPopperPosition : SelectItemAlignedPosition;\n\n    // Silently ignore props that are not supported by `SelectItemAlignedPosition`\n    const popperContentProps =\n      SelectPosition === SelectPopperPosition\n        ? {\n            side,\n            sideOffset,\n            align,\n            alignOffset,\n            arrowPadding,\n            collisionBoundary,\n            collisionPadding,\n            sticky,\n            hideWhenDetached,\n            avoidCollisions,\n          }\n        : {};\n\n    return (\n      <SelectContentProvider\n        scope={__scopeSelect}\n        content={content}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        itemRefCallback={itemRefCallback}\n        selectedItem={selectedItem}\n        onItemLeave={handleItemLeave}\n        itemTextRefCallback={itemTextRefCallback}\n        focusSelectedItem={focusSelectedItem}\n        selectedItemText={selectedItemText}\n        position={position}\n        isPositioned={isPositioned}\n        searchRef={searchRef}\n      >\n        <RemoveScroll as={Slot} allowPinchZoom>\n          <FocusScope\n            asChild\n            // we make sure we're not trapping once it's been closed\n            // (closed !== unmounted when animating out)\n            trapped={context.open}\n            onMountAutoFocus={(event) => {\n              // we prevent open autofocus because we manually focus the selected item\n              event.preventDefault();\n            }}\n            onUnmountAutoFocus={composeEventHandlers(onCloseAutoFocus, (event) => {\n              context.trigger?.focus({ preventScroll: true });\n              event.preventDefault();\n            })}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              // When focus is trapped, a focusout event may still happen.\n              // We make sure we don't trigger our `onDismiss` in such case.\n              onFocusOutside={(event) => event.preventDefault()}\n              onDismiss={() => context.onOpenChange(false)}\n            >\n              <SelectPosition\n                role=\"listbox\"\n                id={context.contentId}\n                data-state={context.open ? 'open' : 'closed'}\n                dir={context.dir}\n                onContextMenu={(event) => event.preventDefault()}\n                {...contentProps}\n                {...popperContentProps}\n                onPlaced={() => setIsPositioned(true)}\n                ref={composedRefs}\n                style={{\n                  // flex layout so we can place the scroll buttons properly\n                  display: 'flex',\n                  flexDirection: 'column',\n                  // reset the outline by default as the content MAY get focused\n                  outline: 'none',\n                  ...contentProps.style,\n                }}\n                onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                  const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n\n                  // select should not be navigated using tab key so we prevent it\n                  if (event.key === 'Tab') event.preventDefault();\n\n                  if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n\n                  if (['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(event.key)) {\n                    const items = getItems().filter((item) => !item.disabled);\n                    let candidateNodes = items.map((item) => item.ref.current!);\n\n                    if (['ArrowUp', 'End'].includes(event.key)) {\n                      candidateNodes = candidateNodes.slice().reverse();\n                    }\n                    if (['ArrowUp', 'ArrowDown'].includes(event.key)) {\n                      const currentElement = event.target as SelectItemElement;\n                      const currentIndex = candidateNodes.indexOf(currentElement);\n                      candidateNodes = candidateNodes.slice(currentIndex + 1);\n                    }\n\n                    /**\n                     * Imperative focus during keydown is risky so we prevent React's batching updates\n                     * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n                     */\n                    setTimeout(() => focusFirst(candidateNodes));\n\n                    event.preventDefault();\n                  }\n                })}\n              />\n            </DismissableLayer>\n          </FocusScope>\n        </RemoveScroll>\n      </SelectContentProvider>\n    );\n  }\n);\n\nSelectContentImpl.displayName = CONTENT_IMPL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItemAlignedPosition\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_ALIGNED_POSITION_NAME = 'SelectItemAlignedPosition';\n\ntype SelectItemAlignedPositionElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectItemAlignedPositionProps extends PrimitiveDivProps, SelectPopperPrivateProps {}\n\nconst SelectItemAlignedPosition = React.forwardRef<\n  SelectItemAlignedPositionElement,\n  SelectItemAlignedPositionProps\n>((props: ScopedProps<SelectItemAlignedPositionProps>, forwardedRef) => {\n  const { __scopeSelect, onPlaced, ...popperProps } = props;\n  const context = useSelectContext(CONTENT_NAME, __scopeSelect);\n  const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);\n  const [contentWrapper, setContentWrapper] = React.useState<HTMLDivElement | null>(null);\n  const [content, setContent] = React.useState<SelectItemAlignedPositionElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n  const getItems = useCollection(__scopeSelect);\n  const shouldExpandOnScrollRef = React.useRef(false);\n  const shouldRepositionRef = React.useRef(true);\n\n  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;\n  const position = React.useCallback(() => {\n    if (\n      context.trigger &&\n      context.valueNode &&\n      contentWrapper &&\n      content &&\n      viewport &&\n      selectedItem &&\n      selectedItemText\n    ) {\n      const triggerRect = context.trigger.getBoundingClientRect();\n\n      // -----------------------------------------------------------------------------------------\n      //  Horizontal positioning\n      // -----------------------------------------------------------------------------------------\n      const contentRect = content.getBoundingClientRect();\n      const valueNodeRect = context.valueNode.getBoundingClientRect();\n      const itemTextRect = selectedItemText.getBoundingClientRect();\n\n      if (context.dir !== 'rtl') {\n        const itemTextOffset = itemTextRect.left - contentRect.left;\n        const left = valueNodeRect.left - itemTextOffset;\n        const leftDelta = triggerRect.left - left;\n        const minContentWidth = triggerRect.width + leftDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const rightEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedLeft = clamp(left, [\n          CONTENT_MARGIN,\n          // Prevents the content from going off the starting edge of the\n          // viewport. It may still go off the ending edge, but this can be\n          // controlled by the user since they may want to manage overflow in a\n          // specific way.\n          // https://github.com/radix-ui/primitives/issues/2049\n          Math.max(CONTENT_MARGIN, rightEdge - contentWidth),\n        ]);\n\n        contentWrapper.style.minWidth = minContentWidth + 'px';\n        contentWrapper.style.left = clampedLeft + 'px';\n      } else {\n        const itemTextOffset = contentRect.right - itemTextRect.right;\n        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;\n        const rightDelta = window.innerWidth - triggerRect.right - right;\n        const minContentWidth = triggerRect.width + rightDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const leftEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedRight = clamp(right, [\n          CONTENT_MARGIN,\n          Math.max(CONTENT_MARGIN, leftEdge - contentWidth),\n        ]);\n\n        contentWrapper.style.minWidth = minContentWidth + 'px';\n        contentWrapper.style.right = clampedRight + 'px';\n      }\n\n      // -----------------------------------------------------------------------------------------\n      // Vertical positioning\n      // -----------------------------------------------------------------------------------------\n      const items = getItems();\n      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n      const itemsHeight = viewport.scrollHeight;\n\n      const contentStyles = window.getComputedStyle(content);\n      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);\n      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);\n      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);\n      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);\n      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth; // prettier-ignore\n      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);\n\n      const viewportStyles = window.getComputedStyle(viewport);\n      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);\n      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);\n\n      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;\n      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;\n\n      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;\n      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;\n      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;\n      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;\n\n      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;\n\n      if (willAlignWithoutTopOverflow) {\n        const isLastItem =\n          items.length > 0 && selectedItem === items[items.length - 1]!.ref.current;\n        contentWrapper.style.bottom = 0 + 'px';\n        const viewportOffsetBottom =\n          content.clientHeight - viewport.offsetTop - viewport.offsetHeight;\n        const clampedTriggerMiddleToBottomEdge = Math.max(\n          triggerMiddleToBottomEdge,\n          selectedItemHalfHeight +\n            // viewport might have padding bottom, include it to avoid a scrollable viewport\n            (isLastItem ? viewportPaddingBottom : 0) +\n            viewportOffsetBottom +\n            contentBorderBottomWidth\n        );\n        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;\n        contentWrapper.style.height = height + 'px';\n      } else {\n        const isFirstItem = items.length > 0 && selectedItem === items[0]!.ref.current;\n        contentWrapper.style.top = 0 + 'px';\n        const clampedTopEdgeToTriggerMiddle = Math.max(\n          topEdgeToTriggerMiddle,\n          contentBorderTopWidth +\n            viewport.offsetTop +\n            // viewport might have padding top, include it to avoid a scrollable viewport\n            (isFirstItem ? viewportPaddingTop : 0) +\n            selectedItemHalfHeight\n        );\n        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;\n        contentWrapper.style.height = height + 'px';\n        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;\n      }\n\n      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;\n      contentWrapper.style.minHeight = minContentHeight + 'px';\n      contentWrapper.style.maxHeight = availableHeight + 'px';\n      // -----------------------------------------------------------------------------------------\n\n      onPlaced?.();\n\n      // we don't want the initial scroll position adjustment to trigger \"expand on scroll\"\n      // so we explicitly turn it on only after they've registered.\n      requestAnimationFrame(() => (shouldExpandOnScrollRef.current = true));\n    }\n  }, [\n    getItems,\n    context.trigger,\n    context.valueNode,\n    contentWrapper,\n    content,\n    viewport,\n    selectedItem,\n    selectedItemText,\n    context.dir,\n    onPlaced,\n  ]);\n\n  useLayoutEffect(() => position(), [position]);\n\n  // copy z-index from content to wrapper\n  const [contentZIndex, setContentZIndex] = React.useState<string>();\n  useLayoutEffect(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n\n  // When the viewport becomes scrollable at the top, the scroll up button will mount.\n  // Because it is part of the normal flow, it will push down the viewport, thus throwing our\n  // trigger => selectedItem alignment off by the amount the viewport was pushed down.\n  // We wait for this to happen and then re-run the positining logic one more time to account for it.\n  const handleScrollButtonChange = React.useCallback(\n    (node: SelectScrollButtonImplElement | null) => {\n      if (node && shouldRepositionRef.current === true) {\n        position();\n        focusSelectedItem?.();\n        shouldRepositionRef.current = false;\n      }\n    },\n    [position, focusSelectedItem]\n  );\n\n  return (\n    <SelectViewportProvider\n      scope={__scopeSelect}\n      contentWrapper={contentWrapper}\n      shouldExpandOnScrollRef={shouldExpandOnScrollRef}\n      onScrollButtonChange={handleScrollButtonChange}\n    >\n      <div\n        ref={setContentWrapper}\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n          position: 'fixed',\n          zIndex: contentZIndex,\n        }}\n      >\n        <Primitive.div\n          {...popperProps}\n          ref={composedRefs}\n          style={{\n            // When we get the height of the content, it includes borders. If we were to set\n            // the height without having `boxSizing: 'border-box'` it would be too big.\n            boxSizing: 'border-box',\n            // We need to ensure the content doesn't get taller than the wrapper\n            maxHeight: '100%',\n            ...popperProps.style,\n          }}\n        />\n      </div>\n    </SelectViewportProvider>\n  );\n});\n\nSelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectPopperPosition\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_POSITION_NAME = 'SelectPopperPosition';\n\ntype SelectPopperPositionElement = React.ComponentRef<typeof PopperPrimitive.Content>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ninterface SelectPopperPositionProps extends PopperContentProps, SelectPopperPrivateProps {}\n\nconst SelectPopperPosition = React.forwardRef<\n  SelectPopperPositionElement,\n  SelectPopperPositionProps\n>((props: ScopedProps<SelectPopperPositionProps>, forwardedRef) => {\n  const {\n    __scopeSelect,\n    align = 'start',\n    collisionPadding = CONTENT_MARGIN,\n    ...popperProps\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n\n  return (\n    <PopperPrimitive.Content\n      {...popperScope}\n      {...popperProps}\n      ref={forwardedRef}\n      align={align}\n      collisionPadding={collisionPadding}\n      style={{\n        // Ensure border-box for floating-ui calculations\n        boxSizing: 'border-box',\n        ...popperProps.style,\n        // re-namespace exposed content custom properties\n        ...{\n          '--radix-select-content-transform-origin': 'var(--radix-popper-transform-origin)',\n          '--radix-select-content-available-width': 'var(--radix-popper-available-width)',\n          '--radix-select-content-available-height': 'var(--radix-popper-available-height)',\n          '--radix-select-trigger-width': 'var(--radix-popper-anchor-width)',\n          '--radix-select-trigger-height': 'var(--radix-popper-anchor-height)',\n        },\n      }}\n    />\n  );\n});\n\nSelectPopperPosition.displayName = POPPER_POSITION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectViewport\n * -----------------------------------------------------------------------------------------------*/\n\ntype SelectViewportContextValue = {\n  contentWrapper?: HTMLDivElement | null;\n  shouldExpandOnScrollRef?: React.RefObject<boolean>;\n  onScrollButtonChange?: (node: SelectScrollButtonImplElement | null) => void;\n};\n\nconst [SelectViewportProvider, useSelectViewportContext] =\n  createSelectContext<SelectViewportContextValue>(CONTENT_NAME, {});\n\nconst VIEWPORT_NAME = 'SelectViewport';\n\ntype SelectViewportElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface SelectViewportProps extends PrimitiveDivProps {\n  nonce?: string;\n}\n\nconst SelectViewport = React.forwardRef<SelectViewportElement, SelectViewportProps>(\n  (props: ScopedProps<SelectViewportProps>, forwardedRef) => {\n    const { __scopeSelect, nonce, ...viewportProps } = props;\n    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);\n    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);\n    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);\n    const prevScrollTopRef = React.useRef(0);\n    return (\n      <>\n        {/* Hide scrollbars cross-browser and enable momentum scroll for touch devices */}\n        <style\n          dangerouslySetInnerHTML={{\n            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`,\n          }}\n          nonce={nonce}\n        />\n        <Collection.Slot scope={__scopeSelect}>\n          <Primitive.div\n            data-radix-select-viewport=\"\"\n            role=\"presentation\"\n            {...viewportProps}\n            ref={composedRefs}\n            style={{\n              // we use position: 'relative' here on the `viewport` so that when we call\n              // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n              // (independent of the scrollUpButton).\n              position: 'relative',\n              flex: 1,\n              // Viewport should only be scrollable in the vertical direction.\n              // This won't work in vertical writing modes, so we'll need to\n              // revisit this if/when that is supported\n              // https://developer.chrome.com/blog/vertical-form-controls\n              overflow: 'hidden auto',\n              ...viewportProps.style,\n            }}\n            onScroll={composeEventHandlers(viewportProps.onScroll, (event) => {\n              const viewport = event.currentTarget;\n              const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;\n              if (shouldExpandOnScrollRef?.current && contentWrapper) {\n                const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);\n                if (scrolledBy > 0) {\n                  const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n                  const cssMinHeight = parseFloat(contentWrapper.style.minHeight);\n                  const cssHeight = parseFloat(contentWrapper.style.height);\n                  const prevHeight = Math.max(cssMinHeight, cssHeight);\n\n                  if (prevHeight < availableHeight) {\n                    const nextHeight = prevHeight + scrolledBy;\n                    const clampedNextHeight = Math.min(availableHeight, nextHeight);\n                    const heightDiff = nextHeight - clampedNextHeight;\n\n                    contentWrapper.style.height = clampedNextHeight + 'px';\n                    if (contentWrapper.style.bottom === '0px') {\n                      viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;\n                      // ensure the content stays pinned to the bottom\n                      contentWrapper.style.justifyContent = 'flex-end';\n                    }\n                  }\n                }\n              }\n              prevScrollTopRef.current = viewport.scrollTop;\n            })}\n          />\n        </Collection.Slot>\n      </>\n    );\n  }\n);\n\nSelectViewport.displayName = VIEWPORT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'SelectGroup';\n\ntype SelectGroupContextValue = { id: string };\n\nconst [SelectGroupContextProvider, useSelectGroupContext] =\n  createSelectContext<SelectGroupContextValue>(GROUP_NAME);\n\ntype SelectGroupElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectGroupProps extends PrimitiveDivProps {}\n\nconst SelectGroup = React.forwardRef<SelectGroupElement, SelectGroupProps>(\n  (props: ScopedProps<SelectGroupProps>, forwardedRef) => {\n    const { __scopeSelect, ...groupProps } = props;\n    const groupId = useId();\n    return (\n      <SelectGroupContextProvider scope={__scopeSelect} id={groupId}>\n        <Primitive.div role=\"group\" aria-labelledby={groupId} {...groupProps} ref={forwardedRef} />\n      </SelectGroupContextProvider>\n    );\n  }\n);\n\nSelectGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'SelectLabel';\n\ntype SelectLabelElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectLabelProps extends PrimitiveDivProps {}\n\nconst SelectLabel = React.forwardRef<SelectLabelElement, SelectLabelProps>(\n  (props: ScopedProps<SelectLabelProps>, forwardedRef) => {\n    const { __scopeSelect, ...labelProps } = props;\n    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);\n    return <Primitive.div id={groupContext.id} {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nSelectLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'SelectItem';\n\ntype SelectItemContextValue = {\n  value: string;\n  disabled: boolean;\n  textId: string;\n  isSelected: boolean;\n  onItemTextChange(node: SelectItemTextElement | null): void;\n};\n\nconst [SelectItemContextProvider, useSelectItemContext] =\n  createSelectContext<SelectItemContextValue>(ITEM_NAME);\n\ntype SelectItemElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectItemProps extends PrimitiveDivProps {\n  value: string;\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst SelectItem = React.forwardRef<SelectItemElement, SelectItemProps>(\n  (props: ScopedProps<SelectItemProps>, forwardedRef) => {\n    const {\n      __scopeSelect,\n      value,\n      disabled = false,\n      textValue: textValueProp,\n      ...itemProps\n    } = props;\n    const context = useSelectContext(ITEM_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);\n    const isSelected = context.value === value;\n    const [textValue, setTextValue] = React.useState(textValueProp ?? '');\n    const [isFocused, setIsFocused] = React.useState(false);\n    const composedRefs = useComposedRefs(forwardedRef, (node) =>\n      contentContext.itemRefCallback?.(node, value, disabled)\n    );\n    const textId = useId();\n    const pointerTypeRef = React.useRef<React.PointerEvent['pointerType']>('touch');\n\n    const handleSelect = () => {\n      if (!disabled) {\n        context.onValueChange(value);\n        context.onOpenChange(false);\n      }\n    };\n\n    if (value === '') {\n      throw new Error(\n        'A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.'\n      );\n    }\n\n    return (\n      <SelectItemContextProvider\n        scope={__scopeSelect}\n        value={value}\n        disabled={disabled}\n        textId={textId}\n        isSelected={isSelected}\n        onItemTextChange={React.useCallback((node) => {\n          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? '').trim());\n        }, [])}\n      >\n        <Collection.ItemSlot\n          scope={__scopeSelect}\n          value={value}\n          disabled={disabled}\n          textValue={textValue}\n        >\n          <Primitive.div\n            role=\"option\"\n            aria-labelledby={textId}\n            data-highlighted={isFocused ? '' : undefined}\n            // `isFocused` caveat fixes stuttering in VoiceOver\n            aria-selected={isSelected && isFocused}\n            data-state={isSelected ? 'checked' : 'unchecked'}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            tabIndex={disabled ? undefined : -1}\n            {...itemProps}\n            ref={composedRefs}\n            onFocus={composeEventHandlers(itemProps.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(itemProps.onBlur, () => setIsFocused(false))}\n            onClick={composeEventHandlers(itemProps.onClick, () => {\n              // Open on click when using a touch or pen device\n              if (pointerTypeRef.current !== 'mouse') handleSelect();\n            })}\n            onPointerUp={composeEventHandlers(itemProps.onPointerUp, () => {\n              // Using a mouse you should be able to do pointer down, move through\n              // the list, and release the pointer over the item to select it.\n              if (pointerTypeRef.current === 'mouse') handleSelect();\n            })}\n            onPointerDown={composeEventHandlers(itemProps.onPointerDown, (event) => {\n              pointerTypeRef.current = event.pointerType;\n            })}\n            onPointerMove={composeEventHandlers(itemProps.onPointerMove, (event) => {\n              // Remember pointer type when sliding over to this item from another one\n              pointerTypeRef.current = event.pointerType;\n              if (disabled) {\n                contentContext.onItemLeave?.();\n              } else if (pointerTypeRef.current === 'mouse') {\n                // even though safari doesn't support this option, it's acceptable\n                // as it only means it might scroll a few pixels when using the pointer.\n                event.currentTarget.focus({ preventScroll: true });\n              }\n            })}\n            onPointerLeave={composeEventHandlers(itemProps.onPointerLeave, (event) => {\n              if (event.currentTarget === document.activeElement) {\n                contentContext.onItemLeave?.();\n              }\n            })}\n            onKeyDown={composeEventHandlers(itemProps.onKeyDown, (event) => {\n              const isTypingAhead = contentContext.searchRef?.current !== '';\n              if (isTypingAhead && event.key === ' ') return;\n              if (SELECTION_KEYS.includes(event.key)) handleSelect();\n              // prevent page scroll if using the space key to select an item\n              if (event.key === ' ') event.preventDefault();\n            })}\n          />\n        </Collection.ItemSlot>\n      </SelectItemContextProvider>\n    );\n  }\n);\n\nSelectItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItemText\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_TEXT_NAME = 'SelectItemText';\n\ntype SelectItemTextElement = React.ComponentRef<typeof Primitive.span>;\ninterface SelectItemTextProps extends PrimitiveSpanProps {}\n\nconst SelectItemText = React.forwardRef<SelectItemTextElement, SelectItemTextProps>(\n  (props: ScopedProps<SelectItemTextProps>, forwardedRef) => {\n    // We ignore `className` and `style` as this part shouldn't be styled.\n    const { __scopeSelect, className, style, ...itemTextProps } = props;\n    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);\n    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);\n    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);\n    const [itemTextNode, setItemTextNode] = React.useState<SelectItemTextElement | null>(null);\n    const composedRefs = useComposedRefs(\n      forwardedRef,\n      (node) => setItemTextNode(node),\n      itemContext.onItemTextChange,\n      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)\n    );\n\n    const textContent = itemTextNode?.textContent;\n    const nativeOption = React.useMemo(\n      () => (\n        <option key={itemContext.value} value={itemContext.value} disabled={itemContext.disabled}>\n          {textContent}\n        </option>\n      ),\n      [itemContext.disabled, itemContext.value, textContent]\n    );\n\n    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;\n    useLayoutEffect(() => {\n      onNativeOptionAdd(nativeOption);\n      return () => onNativeOptionRemove(nativeOption);\n    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);\n\n    return (\n      <>\n        <Primitive.span id={itemContext.textId} {...itemTextProps} ref={composedRefs} />\n\n        {/* Portal the select item text into the trigger value node */}\n        {itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren\n          ? ReactDOM.createPortal(itemTextProps.children, context.valueNode)\n          : null}\n      </>\n    );\n  }\n);\n\nSelectItemText.displayName = ITEM_TEXT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'SelectItemIndicator';\n\ntype SelectItemIndicatorElement = React.ComponentRef<typeof Primitive.span>;\ninterface SelectItemIndicatorProps extends PrimitiveSpanProps {}\n\nconst SelectItemIndicator = React.forwardRef<SelectItemIndicatorElement, SelectItemIndicatorProps>(\n  (props: ScopedProps<SelectItemIndicatorProps>, forwardedRef) => {\n    const { __scopeSelect, ...itemIndicatorProps } = props;\n    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);\n    return itemContext.isSelected ? (\n      <Primitive.span aria-hidden {...itemIndicatorProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nSelectItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectScrollUpButton\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLL_UP_BUTTON_NAME = 'SelectScrollUpButton';\n\ntype SelectScrollUpButtonElement = SelectScrollButtonImplElement;\ninterface SelectScrollUpButtonProps extends Omit<SelectScrollButtonImplProps, 'onAutoScroll'> {}\n\nconst SelectScrollUpButton = React.forwardRef<\n  SelectScrollUpButtonElement,\n  SelectScrollUpButtonProps\n>((props: ScopedProps<SelectScrollUpButtonProps>, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollUp, setCanScrollUp] = React.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n\n  useLayoutEffect(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      const viewport = contentContext.viewport;\n      function handleScroll() {\n        const canScrollUp = viewport.scrollTop > 0;\n        setCanScrollUp(canScrollUp);\n      }\n      handleScroll();\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n\n  return canScrollUp ? (\n    <SelectScrollButtonImpl\n      {...props}\n      ref={composedRefs}\n      onAutoScroll={() => {\n        const { viewport, selectedItem } = contentContext;\n        if (viewport && selectedItem) {\n          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;\n        }\n      }}\n    />\n  ) : null;\n});\n\nSelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectScrollDownButton\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLL_DOWN_BUTTON_NAME = 'SelectScrollDownButton';\n\ntype SelectScrollDownButtonElement = SelectScrollButtonImplElement;\ninterface SelectScrollDownButtonProps extends Omit<SelectScrollButtonImplProps, 'onAutoScroll'> {}\n\nconst SelectScrollDownButton = React.forwardRef<\n  SelectScrollDownButtonElement,\n  SelectScrollDownButtonProps\n>((props: ScopedProps<SelectScrollDownButtonProps>, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollDown, setCanScrollDown] = React.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n\n  useLayoutEffect(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      const viewport = contentContext.viewport;\n      function handleScroll() {\n        const maxScroll = viewport.scrollHeight - viewport.clientHeight;\n        // we use Math.ceil here because if the UI is zoomed-in\n        // `scrollTop` is not always reported as an integer\n        const canScrollDown = Math.ceil(viewport.scrollTop) < maxScroll;\n        setCanScrollDown(canScrollDown);\n      }\n      handleScroll();\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n\n  return canScrollDown ? (\n    <SelectScrollButtonImpl\n      {...props}\n      ref={composedRefs}\n      onAutoScroll={() => {\n        const { viewport, selectedItem } = contentContext;\n        if (viewport && selectedItem) {\n          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;\n        }\n      }}\n    />\n  ) : null;\n});\n\nSelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;\n\ntype SelectScrollButtonImplElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectScrollButtonImplProps extends PrimitiveDivProps {\n  onAutoScroll(): void;\n}\n\nconst SelectScrollButtonImpl = React.forwardRef<\n  SelectScrollButtonImplElement,\n  SelectScrollButtonImplProps\n>((props: ScopedProps<SelectScrollButtonImplProps>, forwardedRef) => {\n  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;\n  const contentContext = useSelectContentContext('SelectScrollButton', __scopeSelect);\n  const autoScrollTimerRef = React.useRef<number | null>(null);\n  const getItems = useCollection(__scopeSelect);\n\n  const clearAutoScrollTimer = React.useCallback(() => {\n    if (autoScrollTimerRef.current !== null) {\n      window.clearInterval(autoScrollTimerRef.current);\n      autoScrollTimerRef.current = null;\n    }\n  }, []);\n\n  React.useEffect(() => {\n    return () => clearAutoScrollTimer();\n  }, [clearAutoScrollTimer]);\n\n  // When the viewport becomes scrollable on either side, the relevant scroll button will mount.\n  // Because it is part of the normal flow, it will push down (top button) or shrink (bottom button)\n  // the viewport, potentially causing the active item to now be partially out of view.\n  // We re-run the `scrollIntoView` logic to make sure it stays within the viewport.\n  useLayoutEffect(() => {\n    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);\n    activeItem?.ref.current?.scrollIntoView({ block: 'nearest' });\n  }, [getItems]);\n\n  return (\n    <Primitive.div\n      aria-hidden\n      {...scrollIndicatorProps}\n      ref={forwardedRef}\n      style={{ flexShrink: 0, ...scrollIndicatorProps.style }}\n      onPointerDown={composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {\n        if (autoScrollTimerRef.current === null) {\n          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n        }\n      })}\n      onPointerMove={composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {\n        contentContext.onItemLeave?.();\n        if (autoScrollTimerRef.current === null) {\n          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n        }\n      })}\n      onPointerLeave={composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {\n        clearAutoScrollTimer();\n      })}\n    />\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * SelectSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'SelectSeparator';\n\ntype SelectSeparatorElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectSeparatorProps extends PrimitiveDivProps {}\n\nconst SelectSeparator = React.forwardRef<SelectSeparatorElement, SelectSeparatorProps>(\n  (props: ScopedProps<SelectSeparatorProps>, forwardedRef) => {\n    const { __scopeSelect, ...separatorProps } = props;\n    return <Primitive.div aria-hidden {...separatorProps} ref={forwardedRef} />;\n  }\n);\n\nSelectSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'SelectArrow';\n\ntype SelectArrowElement = React.ComponentRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface SelectArrowProps extends PopperArrowProps {}\n\nconst SelectArrow = React.forwardRef<SelectArrowElement, SelectArrowProps>(\n  (props: ScopedProps<SelectArrowProps>, forwardedRef) => {\n    const { __scopeSelect, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeSelect);\n    const context = useSelectContext(ARROW_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);\n    return context.open && contentContext.position === 'popper' ? (\n      <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nSelectArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectBubbleInput\n * -----------------------------------------------------------------------------------------------*/\n\nconst BUBBLE_INPUT_NAME = 'SelectBubbleInput';\n\ntype InputProps = React.ComponentPropsWithoutRef<typeof Primitive.select>;\ninterface SwitchBubbleInputProps extends InputProps {}\n\nconst SelectBubbleInput = React.forwardRef<HTMLSelectElement, SwitchBubbleInputProps>(\n  ({ __scopeSelect, value, ...props }: ScopedProps<SwitchBubbleInputProps>, forwardedRef) => {\n    const ref = React.useRef<HTMLSelectElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const prevValue = usePrevious(value);\n\n    // Bubble value change to parents (e.g form change event)\n    React.useEffect(() => {\n      const select = ref.current;\n      if (!select) return;\n\n      const selectProto = window.HTMLSelectElement.prototype;\n      const descriptor = Object.getOwnPropertyDescriptor(\n        selectProto,\n        'value'\n      ) as PropertyDescriptor;\n      const setValue = descriptor.set;\n      if (prevValue !== value && setValue) {\n        const event = new Event('change', { bubbles: true });\n        setValue.call(select, value);\n        select.dispatchEvent(event);\n      }\n    }, [prevValue, value]);\n\n    /**\n     * We purposefully use a `select` here to support form autofill as much as\n     * possible.\n     *\n     * We purposefully do not add the `value` attribute here to allow the value\n     * to be set programmatically and bubble to any parent form `onChange`\n     * event. Adding the `value` will cause React to consider the programmatic\n     * dispatch a duplicate and it will get swallowed.\n     *\n     * We use visually hidden styles rather than `display: \"none\"` because\n     * Safari autofill won't work otherwise.\n     */\n    return (\n      <Primitive.select\n        {...props}\n        style={{ ...VISUALLY_HIDDEN_STYLES, ...props.style }}\n        ref={composedRefs}\n        defaultValue={value}\n      />\n    );\n  }\n);\n\nSelectBubbleInput.displayName = BUBBLE_INPUT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction shouldShowPlaceholder(value?: string) {\n  return value === '' || value === undefined;\n}\n\nfunction useTypeaheadSearch(onSearchChange: (search: string) => void) {\n  const handleSearchChange = useCallbackRef(onSearchChange);\n  const searchRef = React.useRef('');\n  const timerRef = React.useRef(0);\n\n  const handleTypeaheadSearch = React.useCallback(\n    (key: string) => {\n      const search = searchRef.current + key;\n      handleSearchChange(search);\n\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        // Reset `searchRef` 1 second after it was last updated\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n    },\n    [handleSearchChange]\n  );\n\n  const resetTypeahead = React.useCallback(() => {\n    searchRef.current = '';\n    window.clearTimeout(timerRef.current);\n  }, []);\n\n  React.useEffect(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n\n  return [searchRef, handleTypeaheadSearch, resetTypeahead] as const;\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in a list of items,\n * the search and the current item, and returns the next item (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through items starting with that character)\n *\n * We also reorder the items by wrapping the array around the current item.\n * This is so we always look forward from the current item, and picking the first\n * item will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current item from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current item still matches.\n */\nfunction findNextItem<T extends { textValue: string }>(\n  items: T[],\n  search: string,\n  currentItem?: T\n) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0]! : search;\n  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;\n  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));\n  const excludeCurrentItem = normalizedSearch.length === 1;\n  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);\n  const nextItem = wrappedItems.find((item) =>\n    item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextItem !== currentItem ? nextItem : undefined;\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\nconst Root = Select;\nconst Trigger = SelectTrigger;\nconst Value = SelectValue;\nconst Icon = SelectIcon;\nconst Portal = SelectPortal;\nconst Content = SelectContent;\nconst Viewport = SelectViewport;\nconst Group = SelectGroup;\nconst Label = SelectLabel;\nconst Item = SelectItem;\nconst ItemText = SelectItemText;\nconst ItemIndicator = SelectItemIndicator;\nconst ScrollUpButton = SelectScrollUpButton;\nconst ScrollDownButton = SelectScrollDownButton;\nconst Separator = SelectSeparator;\nconst Arrow = SelectArrow;\n\nexport {\n  createSelectScope,\n  //\n  Select,\n  SelectTrigger,\n  SelectValue,\n  SelectIcon,\n  SelectPortal,\n  SelectContent,\n  SelectViewport,\n  SelectGroup,\n  SelectLabel,\n  SelectItem,\n  SelectItemText,\n  SelectItemIndicator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n  SelectSeparator,\n  SelectArrow,\n  //\n  Root,\n  Trigger,\n  Value,\n  Icon,\n  Portal,\n  Content,\n  Viewport,\n  Group,\n  Label,\n  Item,\n  ItemText,\n  ItemIndicator,\n  ScrollUpButton,\n  ScrollDownButton,\n  Separator,\n  Arrow,\n};\nexport type {\n  SelectProps,\n  SelectTriggerProps,\n  SelectValueProps,\n  SelectIconProps,\n  SelectPortalProps,\n  SelectContentProps,\n  SelectViewportProps,\n  SelectGroupProps,\n  SelectLabelProps,\n  SelectItemProps,\n  SelectItemTextProps,\n  SelectItemIndicatorProps,\n  SelectScrollUpButtonProps,\n  SelectScrollDownButtonProps,\n  SelectSeparatorProps,\n  SelectArrowProps,\n};\n"],"names":["Check","createLucideIcon","d","key","ChevronDown","ChevronUp","createCollection","name","PROVIDER_NAME","createCollectionContext","createCollectionScope","createContextScope","CollectionProviderImpl","useCollectionContext","collectionRef","current","itemMap","Map","CollectionProvider","scope","children","props","ref","React","jsx","displayName","COLLECTION_SLOT_NAME","CollectionSlotImpl","createSlot","CollectionSlot","forwardedRef","context","composedRefs","useComposedRefs","ITEM_SLOT_NAME","ITEM_DATA_ATTR","CollectionItemSlotImpl","CollectionItemSlot","itemData","set","delete","Provider","Slot","ItemSlot","collectionNode","orderedNodes","Array","from","querySelectorAll","items","values","sort","a","b","indexOf","DirectionContext","react__WEBPACK_IMPORTED_MODULE_0__","createContext","useDirection","localDir","globalDir","useContext","clamp","value","min","max","Math","sides","floating_ui_utils_min","floating_ui_utils_max","round","floor","createCoords","v","x","y","oppositeSideMap","left","right","bottom","top","oppositeAlignmentMap","start","end","floating_ui_utils_evaluate","param","floating_ui_utils_getSide","placement","split","floating_ui_utils_getAlignment","getOppositeAxis","axis","getAxisLength","yAxisSides","Set","floating_ui_utils_getSideAxis","has","floating_ui_utils_getOppositeAlignmentPlacement","replace","alignment","lrPlacement","rlPlacement","tbPlacement","btPlacement","getOppositePlacement","side","floating_ui_utils_getPaddingObject","padding","floating_ui_utils_rectToClientRect","rect","width","height","computeCoordsFromPlacement","_ref","rtl","coords","reference","floating","sideAxis","alignmentAxis","alignLength","isVertical","commonX","commonY","commonAlign","computePosition","config","strategy","middleware","platform","validMiddleware","filter","Boolean","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","i","length","fn","nextX","nextY","data","reset","initialPlacement","elements","detectOverflow","state","options","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","getSideOffsets","overflow","isAnySideFullyClipped","some","originSides","convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","hasWindow","window","getNodeName","node","nodeName","toLowerCase","getWindow","_node$ownerDocument","ownerDocument","defaultView","isNode","document","documentElement","Node","Element","isHTMLElement","HTMLElement","isShadowRoot","ShadowRoot","invalidOverflowDisplayValues","isOverflowElement","overflowX","overflowY","display","floating_ui_utils_dom_getComputedStyle","test","tableElements","topLayerSelectors","isTopLayer","selector","matches","_e","transformProperties","willChangeValues","containValues","isContainingBlock","elementOrCss","webkit","isWebKit","css","containerType","backdropFilter","willChange","includes","contain","CSS","supports","lastTraversableNodeNames","isLastTraversableNode","getComputedStyle","getNodeScroll","scrollLeft","scrollTop","scrollX","scrollY","getParentNode","result","assignedSlot","parentNode","host","getOverflowAncestors","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","getNearestOverflowAncestor","body","isBody","win","frameElement","getFrameElement","concat","visualViewport","parent","Object","getPrototypeOf","getCssDimensions","parseFloat","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","domElement","getBoundingClientRect","Number","isFinite","noOffsets","getVisualOffsets","offsetLeft","offsetTop","includeScale","isFixedStrategy","isFixed","clientRect","scale","visualOffsets","shouldAddVisualOffsets","floatingOffsetParent","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","getWindowScrollBarX","leftScroll","getHTMLOffset","scroll","htmlRect","absoluteOrFixed","getClientRectFromClippingAncestor","clippingAncestor","getViewportRect","html","clientWidth","clientHeight","visualViewportBased","windowScrollbarX","doc","bodyStyles","bodyMarginInline","compatMode","marginLeft","marginRight","clippingStableScrollbarWidth","abs","getDocumentRect","scrollWidth","scrollHeight","direction","getInnerBoundingClientRect","isStaticPositioned","position","getTrueOffsetParent","polyfill","rawOffsetParent","svgOffsetParent","getContainingBlock","currentNode","getOffsetParentFn","getDimensionsFn","getDimensions","floatingDimensions","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsets","offsetRect","htmlOffset","topLayer","clippingAncestors","getClippingElementAncestors","cache","cachedResult","get","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","hasFixedPositionAncestor","stopNode","ancestor","_c","firstClippingAncestor","clippingRect","reduce","accRect","getClientRects","rectsAreEqual","floating_ui_dom_arrow","arrowDimensions","isYAxis","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","largestPossiblePadding","minPadding","maxPadding","center","offset","shouldAddOffset","arrow","alignmentOffset","centerOffset","floating_ui_dom_computePosition","mergedOptions","platformWithCache","index","isClient","react","useLayoutEffect","deepEqual","keys","toString","isArray","hasOwnProperty","call","$$typeof","getDPR","devicePixelRatio","roundByDPR","dpr","useLatestRef","useRef","arrow$1","floating_ui_react_dom_offset","deps","floating_ui_dom_offset","_middlewareData$offse","_middlewareData$arrow","diffCoords","floating_ui_react_dom_shift","floating_ui_dom_shift","checkMainAxis","checkCrossAxis","limiter","detectOverflowOptions","mainAxisCoord","crossAxisCoord","minSide","maxSide","limitedCoords","enabled","floating_ui_react_dom_limitShift","floating_ui_dom_limitShift","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse2","isOriginSide","floating_ui_react_dom_flip","floating_ui_dom_flip","_middlewareData$flip","_middlewareData$flip2","_overflowsData$filter","_overflowsData$filter2","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","initialSideAxis","isBasePlacement","getExpandedPlacements","oppositePlacement","hasFallbackAxisSideDirection","push","getOppositeAxisPlacements","getSideList","isStart","map","placements","overflows","overflowsData","flip","floating_ui_utils_getAlignmentSides","mainAlignmentSide","every","nextIndex","nextPlacement","resetPlacement","currentSideAxis","acc","floating_ui_react_dom_size","floating_ui_dom_size","_state$middlewareData","_state$middlewareData2","heightSide","widthSide","apply","maximumClippingHeight","maximumClippingWidth","overflowAvailableHeight","overflowAvailableWidth","noShift","shift","availableHeight","availableWidth","xMin","xMax","yMin","yMax","nextDimensions","floating_ui_react_dom_hide","floating_ui_dom_hide","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","floating_ui_react_dom_arrow","Arrow","forwardRef","arrowProps","react_jsx_runtime","react_primitive_dist","WV","svg","viewBox","preserveAspectRatio","asChild","points","POPPER_NAME","createPopperContext","createPopperScope","PopperProvider","usePopperContext","Popper","__scopePopper","anchor","setAnchor","onAnchorChange","ANCHOR_NAME","PopperAnchor","virtualRef","anchorProps","anchorRef","previousAnchor","Primitive","div","CONTENT_NAME","PopperContentProvider","useContentContext","PopperContent","sideOffset","align","alignOffset","arrowPadding","avoidCollisions","collisionBoundary","collisionPadding","collisionPaddingProp","sticky","hideWhenDetached","updatePositionStrategy","onPlaced","contentProps","content","setContent","setArrow","arrowSize","useSize","size","setSize","useState","react_use_layout_effect_dist","resizeObserver","ResizeObserver","entries","entry","borderSizeEntry","borderSize","observe","box","unobserve","arrowWidth","arrowHeight","hasExplicitBoundaries","isNotNull","refs","floatingStyles","isPositioned","useFloating","externalReference","externalFloating","transform","whileElementsMounted","open","setData","latestMiddleware","setLatestMiddleware","_reference","_setReference","_floating","_setFloating","setReference","useCallback","referenceRef","setFloating","floatingRef","referenceEl","floatingEl","dataRef","hasWhileElementsMounted","whileElementsMountedRef","platformRef","openRef","update","then","fullData","isMountedRef","react_dom","flushSync","useMemo","initialStyles","args","autoUpdate","frameId","ancestorScroll","ancestorResize","elementResize","layoutShift","IntersectionObserver","animationFrame","ancestors","forEach","addEventListener","passive","cleanupIo","observeMove","onMove","timeoutId","io","root","cleanup","_io","clearTimeout","disconnect","refresh","skip","threshold","elementRectForRootMargin","insetTop","insetRight","rootMargin","isFirstUpdate","handleObserve","ratio","intersectionRatio","setTimeout","reobserveFrame","firstEntry","target","cancelAnimationFrame","requestAnimationFrame","_resizeObserver","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","removeEventListener","limitShift","anchorWidth","anchorHeight","contentStyle","style","setProperty","floatingUIarrow","transformOrigin","hide","placedSide","placedAlign","getSideAndAlignFromPlacement","handlePlaced","useCallbackRef","arrowX","arrowY","cannotCenterArrow","contentZIndex","setContentZIndex","zIndex","minWidth","join","visibility","pointerEvents","dir","onArrowChange","shouldHideArrow","animation","ARROW_NAME","OPPOSITE_SIDE","PopperArrow","contentContext","baseSide","isArrowHidden","noArrowAlign","arrowXCenter","arrowYCenter","VISUALLY_HIDDEN_STYLES","freeze","border","margin","clip","whiteSpace","wordWrap","VisuallyHidden","span","OPEN_KEYS","SELECTION_KEYS","SELECT_NAME","Collection","useCollection","createSelectContext","createSelectScope","usePopperScope","SelectProvider","useSelectContext","SelectNativeOptionsProvider","useSelectNativeOptionsContext","Select","__scopeSelect","openProp","defaultOpen","onOpenChange","valueProp","defaultValue","onValueChange","autoComplete","disabled","required","form","popperScope","trigger","setTrigger","valueNode","setValueNode","valueNodeHasChildren","setValueNodeHasChildren","setOpen","useControllableState","prop","defaultProp","onChange","caller","setValue","triggerPointerDownPosRef","isFormControl","closest","nativeOptionsSet","setNativeOptionsSet","nativeSelectKey","option","jsxs","onTriggerChange","onValueNodeChange","onValueNodeHasChildrenChange","contentId","useId","onNativeOptionAdd","prev","add","onNativeOptionRemove","optionsSet","SelectBubbleInput","tabIndex","event","TRIGGER_NAME","SelectTrigger","triggerProps","isDisabled","getItems","pointerTypeRef","searchRef","handleTypeaheadSearch","resetTypeahead","useTypeaheadSearch","enabledItems","item","currentItem","find","nextItem","findNextItem","search","handleOpen","pointerEvent","pageX","pageY","button","type","role","shouldShowPlaceholder","onClick","composeEventHandlers","currentTarget","focus","onPointerDown","pointerType","hasPointerCapture","pointerId","releasePointerCapture","ctrlKey","preventDefault","onKeyDown","isTypingAhead","altKey","metaKey","VALUE_NAME","SelectValue","className","placeholder","valueProps","hasChildren","Fragment","SelectIcon","iconProps","SelectPortal","PortalPrimitive","SelectContent","fragment","setFragment","DocumentFragment","SelectContentImpl","frag","ReactDOM","SelectContentProvider","useSelectContentContext","onCloseAutoFocus","onEscapeKeyDown","onPointerDownOutside","viewport","setViewport","selectedItem","setSelectedItem","selectedItemText","setSelectedItemText","setIsPositioned","firstValidItemFoundRef","hideOthers","useFocusGuards","focusFirst","firstItem","restItems","lastItem","slice","PREVIOUSLY_FOCUSED_ELEMENT","activeElement","candidate","candidates","scrollIntoView","block","focusSelectedItem","pointerMoveDelta","handlePointerMove","handlePointerUp","contains","capture","once","close","itemRefCallback","isFirstValidItem","isSelectedItem","handleItemLeave","itemTextRefCallback","SelectPosition","SelectPopperPosition","SelectItemAlignedPosition","popperContentProps","onViewportChange","onItemLeave","RemoveScroll","as","allowPinchZoom","FocusScope","trapped","onMountAutoFocus","onUnmountAutoFocus","preventScroll","DismissableLayer","disableOutsidePointerEvents","onFocusOutside","onDismiss","id","onContextMenu","flexDirection","outline","isModifierKey","candidateNodes","reverse","currentElement","currentIndex","popperProps","contentWrapper","setContentWrapper","shouldExpandOnScrollRef","shouldRepositionRef","triggerRect","contentRect","valueNodeRect","itemTextRect","itemTextOffset","leftDelta","minContentWidth","contentWidth","clampedLeft","rightEdge","innerWidth","rightDelta","clampedRight","leftEdge","innerHeight","CONTENT_MARGIN","itemsHeight","contentStyles","contentBorderTopWidth","parseInt","borderTopWidth","contentPaddingTop","contentBorderBottomWidth","borderBottomWidth","fullContentHeight","paddingBottom","minContentHeight","viewportStyles","viewportPaddingTop","viewportPaddingBottom","topEdgeToTriggerMiddle","selectedItemHalfHeight","contentTopToItemMiddle","isLastItem","viewportOffsetBottom","isFirstItem","clampedTopEdgeToTriggerMiddle","minHeight","maxHeight","handleScrollButtonChange","SelectViewportProvider","onScrollButtonChange","boxSizing","useSelectViewportContext","VIEWPORT_NAME","SelectViewport","nonce","viewportProps","viewportContext","prevScrollTopRef","dangerouslySetInnerHTML","__html","flex","onScroll","scrolledBy","prevHeight","nextHeight","clampedNextHeight","heightDiff","justifyContent","GROUP_NAME","SelectGroupContextProvider","useSelectGroupContext","SelectGroup","groupProps","groupId","LABEL_NAME","SelectLabel","labelProps","groupContext","ITEM_NAME","SelectItemContextProvider","useSelectItemContext","SelectItem","textValue","textValueProp","itemProps","isSelected","setTextValue","isFocused","setIsFocused","textId","handleSelect","onItemTextChange","prevTextValue","textContent","trim","onFocus","onBlur","onPointerUp","onPointerMove","onPointerLeave","ITEM_TEXT_NAME","SelectItemText","itemTextProps","itemContext","nativeOptionsContext","itemTextNode","setItemTextNode","nativeOption","ITEM_INDICATOR_NAME","SelectItemIndicator","itemIndicatorProps","SCROLL_UP_BUTTON_NAME","SelectScrollUpButton","canScrollUp","setCanScrollUp","handleScroll","SelectScrollButtonImpl","onAutoScroll","SCROLL_DOWN_BUTTON_NAME","SelectScrollDownButton","canScrollDown","setCanScrollDown","maxScroll","ceil","scrollIndicatorProps","autoScrollTimerRef","clearAutoScrollTimer","clearInterval","activeItem","flexShrink","setInterval","SelectSeparator","separatorProps","SelectArrow","prevValue","usePrevious","previous","select","descriptor","getOwnPropertyDescriptor","HTMLSelectElement","prototype","Event","bubbles","dispatchEvent","onSearchChange","handleSearchChange","timerRef","updateSearch","startIndex","normalizedSearch","isRepeated","char","wrappedItems","array","_","startsWith","Root","Trigger","Value","Icon","Portal","Content","Viewport","Group","Label","Item","ItemText","ItemIndicator","ScrollUpButton","ScrollDownButton","Separator"],"sourceRoot":""}